{
  "users": [
    {
      "id": 1,
      "name": "Dmitriy",
      "password": "123"
    }
  ],
  "catalogs": [
    {
      "id": 1,
      "title": "Frontend",
      "description": "Конспекты по основным UI технологиям и библиотекам"
    },
    {
      "id": 2,
      "title": "Internet",
      "description": "Общие сведения о работе сети"
    },
    {
      "id": 3,
      "title": "Linux",
      "description": "Операционная система Linux"
    },
    {
      "id": 4,
      "title": "Golang",
      "description": "Конспекты по языку Go"
    }
  ],
  "sections": [
    {
      "title": "Webpack",
      "catalog_id": 1,
      "id": 1
    },
    {
      "title": "Babel",
      "catalog_id": 1,
      "id": 2
    },
    {
      "title": "React",
      "catalog_id": 1,
      "id": 3
    },
    {
      "title": "Redux",
      "catalog_id": 1,
      "id": 4
    },
    {
      "title": "Code style",
      "catalog_id": 1,
      "id": 5
    },
    {
      "title": "Tests",
      "catalog_id": 1,
      "id": 6
    },
    {
      "title": "Общее",
      "catalog_id": 3,
      "id": 7
    },
    {
      "title": "Стандартные библиотеки",
      "catalog_id": 4,
      "id": 8
    },
    {
      "title": "Основы языка",
      "catalog_id": 4,
      "id": 9
    }
  ],
  "articles": [
    {
      "id": 1,
      "section_id": 1,
      "title": "Начало работы Webpack",
      "text": "***Webpack***\n Webpack - программа сборщик, собирает модули в файл(ы), определённого в настройках вида.\nWebpack-у - необходимо иметь входную точку, что бы построить граф зависимостей перед тем,\nкак начать сборку. 5 версия работает в браузерах ES5+, и с Node 10+. Так же сам транспилирует,\nмодули ES2015 под браузеры в бандле.\n\nЗачем: \n1) Собирает множество файлов которые зависят друг от друга в 1 минифицированый, \nпозволяя использовать все виды импортов\n2) Позволяет работать с разными типами файлов за счёт лоадеров и плагинов\n\nГраф зависимостей - структура, которую рекурсивно строит webpack, что бы при сборке собрать \nвсе необходимые для нашего приложения зависимости, файлы и модули в бандл для браузера.\n\nУстанавливаем webpack и webpack-cli (для работы через терминал)\n```\nnpm i -D webpack webpack-cli\n```\nЗапускаем: npx webpack (с флагом --production - минифицированный, --development - нет, \n--watch следит за изменениями файлов, при изменении пересобирает, но не обновляет в браузере), все настройки при этом по-умолчанию\n\n```\nnpx webpack\n```",
      "tags": [
        4
      ]
    },
    {
      "id": 2,
      "section_id": 1,
      "title": "Конфигурация (TypeScript)",
      "text": "***Конфигурация***\n Вообще webpack может работать и без конфига (исп дефолтные настройки), \nно рекомендуется настраивать самому, для более гибкой и полной сборки.\n\nКонфиг может быть объектом или функцией, которая принимает объект env переменных\n* JS файл - module.exports = { конфиг }\n* JS функция - module.exports = () = { ...логика return { конфиг } }\n\n[онлайн генератор конфига](https://createapp.dev/webpack)\n\n!Важно Webpack можно (нужно) использовать с TypeScript,\nдля типизации необходимо установить следующие пакеты\n```\nnpm i -D node-ts typescript @types/webpack @types/node\n```\nИ настроить tsconfig, после чего мы можем деструктурировать конфиг \nи нам будут доступны следующие типы:\n* webpack.Configuration - конфиг файл\n* webpack.RuleSetRule[] - массив rules\n* webpack.WebpackPluginInstance[] - массив плагинов\n* webpack.ResolveOptions - resolve опции\n* и другие\n\nТак же отдельно типизируется\n```\nimport type {Configuration as DevServerConfiguration} from \"webpack-dev-server\";\n```\n",
      "tags": [
        4
      ]
    },
    {
      "id": 3,
      "section_id": 1,
      "title": "Работа с модулями (imports)",
      "text": "***Модули***\n Webpack поддерживает следующие виды импортов:\n\n1) ECMAScript modules - классический import/export\n! Работая с тайпскрипт, в tscongig рекомендуется указать:\n```\n\"allowSyntheticDefaultImports\": true, // если у пакета нет default импорта, создаст его вместо * as React        \n\"esModuleInterop\": true, // Позволит импортить CommonJS как ESModule\n```\n2) CommonJS modules - \"нодовский\" module.export = {} /require()\n\n3) AMD modules - асинхронные модули, где функция define (или её аналог require) принимает первым агрументом \nмассив зависимостей из модулей, и если они присутствуют в сборке, выполняет 2-ой аргумент,\ncallback. Сама функция define определена в пакете-загрузчике, таких как RequireJS, который\nвам придётся использовать, если вы хотите использовать модули типа AMD.\n! В данный момент устаревает, но были оч. популярны\n```\ndefine(['jquery', 'underscore'], function ($, _) {\n    // логика\n    return\n});\n```\n\n4) Assets - @import внутри css/sass/less файлов\n```\n@import './reset.css'\n```\n\n5) WebAssembly modules - url(...) or HTML <img src=...> file.\n```\n.windows-icon {\n  background-image: url(\"../windows.png\");\n}\n```\n\n***Абсолютные пути***\nМы можем использовать абсолютные пути, для этого необходимо:\n1) Указать предпочитать абсолютный путь\n2) Указать откуда будут импортироваться модули\n```\nresolve: {\n    preferAbsolute: true,\n    modules: [paths.src, 'node_modules'],\n}\n```\n3) Если используем TypeScript, указать в tsconfig базовый url \nи директорию откуда будет начинаться абсолютный путь \n```\n\"baseUrl\": \".\",                        \n\"paths\": {\n  \"*\": [\n    \"./src/*\"\n  ],\n}, \n```",
      "tags": [
        4
      ]
    },
    {
      "id": 4,
      "section_id": 1,
      "title": "Основные настройки",
      "text": "###Основные настройки###\n***mode***\n mode: 'production' | 'development' | 'none' - поле необходимо для настройки сборки для определённой среды,\nпри запуске скрипта можем указать webpack --mode=development, в process.env.NODE_ENV \nпоявится установленное значение. По-умолчанию production.\n***entry***\nentry: путь к входному файлу, по-умолчанию ./src/index.js, может быть массивом \n\t(несколько точек входа, для использования чанков)\n\n* вместо строки чанка, можно передать объект, в нём настроить,dependOn - чанк, \nкоторый обязательно должен быть загружен перед текущим, который в свою очаредь \nможет быть массивом из модулей ['react', 'react-dom'], filename -имя, import - модули\nкоторые обязательно должны быть загружены перед текущим, runtime  имя в рантайме,\n***output***\noutput: путь выходного файла (может быть в строку или { path, filename }), \n по-умолчанию dist/main.js В отличие от точки входа, точка выхода может быть только\n одна, В поле pathname - необходимо указать шаблон, например\n'[name][contenthash].bundle.js', для того, что бы все имена файлов были уникальными.\n\n* output.assetModuleFilename - аналог file-loader, в данном поле пишется шаблон именования файлов в лоадерах\n{ test: /форматы файлов/, type: 'asset/resource' }\t\n\n* output.publicPath Здесь же можно указать publicPath - url на котором будет находиться данная сборка, \"/\".\nЭто необходимо для корректной работы react-router-dom v6.8 (createBrowserRouter)\nТак же можно установить publicPath, что бы собирать сразу на серв, и передать в него значение \nenv переменной __webpack_public_path__.\t\n\n* output.clear = true - очищает out директорию перед новой сборкой, замена Clean плагина\n***target***\ntarget: свойство, которое говорит где будет разворачиваться наше приложение. ('web', 'node', ...)\n***optimization***\noptimization: поле настроек для оптимизации\n\n* При подключении сторонних библиотек их код собирается в бандл, если точек входа будет 2\n(2 бандла), по умолчанию в каждом из них будет копия библиотеки. Что бы этого избежать,\nпишем здесь splitChunks: { chunks: 'all' } - вынесет общий код в файл с пометкой vendors",
      "tags": [
        4
      ]
    },
    {
      "id": 5,
      "section_id": 1,
      "title": "Loaders (module.rules)",
      "text": "***loaders***\n loaders: по-умолчанию, webpack собирает только js и json, для остальных форматов файлов\n\tнужны Loader-ы. Loaders прописываются в свойстве module -> rules, в виде массива\n\tloaders, с 2мя обязательными св-вами test - файлы, которые нужно трансформировать,\n\tuse - лоадер, который нужно использовать module: { rules: [ { test, use } ] }.\n\n- так же можно прописывать \"инлайн\", но устарело в webpack 5.\n- loaders могут выстраивать цепочку, и в каждый след лоадер, будет попадать преобразованный\nпредидущим модуль, НО ПО ИТОГУ WEBPACK ЖДЁТ JAVASCRIPT\n- если нам нужен импорт из node_module то используем след синтаксис import \"~package.css\"\n\n* на один формат фалов, может быть необходимость использовать несколько лоадеров,\nнапример .css - для этого, передаём в use массив loaders, который будет применён с конца\n[{ loader:'style-loader' }, { loader:'css-loader }, { loader:'sass-loader' }] - sass 1ый, \nв каждый из этих объектов можно передать опции\n\n* style-loader - помещает css в тэг style в head, можно заменить на MiniCssExtractPlugin.loader\nпри установленном mini-css-extract-plugin, и собирать css не в js а в отдельную папку\nв директории с билдом\n\n* css-loader - позволяет делать импорты вида import './styles.css', так же здесь можно\nнастроить css модули, для этого необходимо передать вместо строки css-loader, объект где\nmodules.auto - функция выбирающая файлы, подходящие для правила, \nmodules.localIdentName - шаблон для имени классов\n```\n{\n  loader: 'css-loader',\n  options: {\n    modules: {\n      auto: (resPath: string) => Boolean(resPath.includes('.module.')),\n      localIdentName: isDev\n        ? '[path][name]__[local]--[hash:base64:5]'\n        : '[hash:base64:8]',\n    },\n  },\n}\n```\n\n* sass-loader (less, scss, stylus) - позволяет компилировать css код препроцессоров\n! При использовании TypeScript для файлов со стилями, необходимо необходимо объявить типы в global.d.ts\n```\ndeclare module '/\\.(sc|sa|c)ss$/' {\n\tinterface IClassNames {\n\t\t[className: string]: string\n\t}\n\tconst classNames: IClassNames;\n\texport = classNames;\n}\n```\n\n* file-loader - позволяет работать с файлами (картинками png, jpeg etc, а так же url(path) в css) \nтак же file-loader позволяет работать со шрифтами\n! Устарел - замена asset/resource, можно указать output.assetModuleFilename: \n'images/[hash][ext][query]' - шаблон для имени и пути к статике\n```\n{\n  test: /\\.png/,\n  type: 'asset/resource'\n}\n```\n! При использовании TypeScript для файлов со стилями, необходимо объявить типы в global.d.ts\n```\ndeclare module '*.png';\ndeclare module '*.jpg';\ndeclare module '*.jpeg';\ndeclare module '*.svg' {\n\timport React from 'react';\n\n\tconst SVG: React.VFC<React.SVGProps<SVGSVGElement>>;\n\texport default SVG;\n}\n```\n* xml-loader - xml файлы , и т д. смотрим доку\n\n* ts-loader - позволяет компилировать JSX и TypeScript в JS\n\n* babel-loader - позволяет использовать пресеты babel, для компиляции,\nнужен для Jest, так как он не может работать с TS без него.\n! Обязательно должен быть перед ts-loader, иначе сборка упадёт\n```\n{\n  test: /\\.m?js$/,\n  exclude: /node_modules/,\n  use: {\n    loader: \"babel-loader\",\n    options: {\n      presets: ['@babel/preset-env']\n    }\n  }\n}\n```\n\n***работа с файлами***\n* svgr-loader - импортировать svg, преобразуя их в реакт компоненты.\n```\n{\n  test: /\\.svg$/,\n  use: ['@svgr/webpack'],\n}\n```\n! при работе с typescript, необходимо объявить тип в declare.d.ts\n```\ndeclare module \"*.svg\" {\n    const content: React.FunctionComponent<React.SVGAttributes<SVGElement>>;\n    export default content;\n}\n```\n* asset/resource - используется в webpack5 и выше, вместо file-loader, по сути лоадер,\nпомимо изображений, позволяет работать со шрифтами\n```\n{\n  test: /\\.(png|jpe?g|gif/woff2/woff)$/,\n  type: 'asset/resource'\n}\n```\n! при работе с typescript, необходимо объявить тип в declare.d.ts\n```\ndeclare module \"*.png\";\ndeclare module \"*.jpg\";\ndeclare module \"*.jpeg\";\n```",
      "tags": [
        4
      ]
    },
    {
      "id": 6,
      "section_id": 1,
      "title": "Plugins",
      "text": "plugins: - если loader используются для трансформации конкретных форматов, плагины имеют более \n\tширокие функции, например хот-релоад, отчистка директории перед сборкой, работа с HTML.\n\tпередается в виде массива экземпляров класса [new Plugin({ ...settings })].\n\n* Можно написать самому, по факту класс, с обязательным методом apply, \nи не обяз. свойсвом опции (взаимодействие в конструкторе)\n```\nclass MyPlugin{\n  apply(compiler) {\n   compiler.hooks.run.tap('MyPlugin', (compilation) => ...\n```\n* html-webpack-plugin - позволяет работать c HTML, в прод, можно минимизировать\nminify: { collapsWhitespace: true }, так же указать html шаблон { template: paths.html }и т п \n\n* copy-webpack-plugin  - позволяет скопировать в сборку файлы, которые не нужно будет компилировать,\nв настройки принимает массив объектов { from: 'path', to: 'path' } - для каждого файла\n\n* mini-css-extract-plugin - позволяет хранить css не в head html-я, а в отдельном файле\nНО НЕОБХОДИМО ПЕРЕДАТЬ В ЛОАДЕР экземпляр статического метода \nMiniCssExtractPlugin.loader, СЛЕВА, последним в очареди обработки, и в настройках плагина\nуказать pathname. Можно минимизировать и оптимизировать как и  html-webpack-plugin\n\n* webpack.ProgressPlugin - позволяет видеть в консоли логи с процентом сборки и текущим этапом\n\n* webpack-bundle-analyzer - позволяет вывести граф зависимостей с указанием размеров модулей\n\n* webpack.DefinePlugin - позволяет прокинуть глобальные переменны\n```\nnew webpack.DefinePlugin({\n  IS_DEV: isDev\n});\n```\n! при использовании TypeScript необходимо указать переменные в global.d.ts\n```\ndeclare const IS_DEV: boolean;\n```\n* webpack.HotModuleReplacementPlugin - позволяет подтягивать изменения кода не перезагружая страницу.\nИспользовать только в dev режиме, в webpack-dev-server необходимо передать флаг hot: true,\n! Но он плохо работает с реакт компонентами, поэтому лучше использовать @pmmmwh/react-refresh-webpack-plugin\n```\nnew webpack.HotModuleReplacementPlugin();\n```\n* @pmmmwh/react-refresh-webpack-plugin - позволяет подтягивать изменения кода не перезагружая страницу.\nХорошо работает с реакт.\n```\nnew ReactRefreshWebpackPlugin()\n```",
      "tags": [
        4
      ]
    },
    {
      "id": 7,
      "section_id": 1,
      "title": "Resolves",
      "text": "***Resolve доп настройки webpack ***\n\t\n* Абсолютный импорт\n```\npreferAbsolute: true,\nresolve.modules: [paths.src, 'node_modules'] - массив путей, где искать модули\n```\n! При использовании TypeScript, необходимо показать TS, что мы используем абсолютные импорты:\n```\n\"baseUrl\": \".\",\n\"*\": [\n  \"./src/*\"\n],\n```\n\n* mainFiles: ['index'] - имя главного файла в модуле\n\n* resolve.alias: позволяет оптимизировать пути импортов, задать шаблоны для пути\nили подменять путь\n```\n{ \n  name(пакета): path // заменить оригинальный пакет этим (лежащим в path)\n  '@name': path.resolve(...) // заменить оригинальный путь импортов этим\n  'UI': path.resolve(__dirname, 'src', 'components', 'ui') // заменить оригинальный путь импортов этим\n}\n```\n! При использовании TypeScript, необходимо показать TS, какие используются alias:\n```\n\"baseUrl\": \".\",\n\"paths\": {\n  \"UI\": [\"src/components/ui/*\"]\n}\n```\n* extensions: ['.js', '.jsx'] - указывает разрешённые к экспорту форматы (их можно будет не указывать вручную)",
      "tags": [
        4
      ]
    },
    {
      "id": 8,
      "section_id": 1,
      "title": "Dev server",
      "text": "***DevServer***\ndevServer: настройка позволяет сделать разработку удобнее, пересобирая код и обновляя приложение в браузере\nпри внесении изменений в файлы ! Необходим  webpack-dev-server\n\n* webpack-dev-server -пакет, необходимый для реализации, указываем путь к входному файлу СБОРКИ! и порт, \n{ path: 'dist/index.js', port: 8080 }\n\n* hot: bool - хот-релоад в зависимости от значения переменной NODE_ENV и пишем скрипт \n(webpack-dev-server --open(открывает прил в окне) --mode development --hot)\n\n* historyApiFallback: true - обязательный флаг в разработке, позволяет обновлять не домашнюю страницу в браузере,\n не получая 404 ошибку\n\n* devtool - позволяет управлять отображением source-map\n```\ndevtool: isDev ? 'inline-source-map' : undefined,\n```",
      "tags": [
        4
      ]
    },
    {
      "id": 9,
      "section_id": 4,
      "title": "Async reducer",
      "text": "***Async reducer***\nЧто бы уменьшить размер бандла, можно сделать некоторые редьюсеры асинхронными.\nПо примеру lazy-компонентов. И подгружать их с помощю reducerManager.\n\nreducerManager - это функция, которую, как правило распологают рядом с store.ts,\nона принимает initialReducers (редюсеры, необходимые в main бандле)\n```\nexport function createReducerManager(initialReducers: ReducersMapObject< RootState >): ReducerManager {\n  const reducers = { ...initialReducers }\n\n  let combinedReducer = combineReducers(reducers)\n\n  let keysToRemove: (keyof RootState)[] = [] // массив ключей редьюсеров, которые необходимо исключить\n\n  return {\n    getReducerMap: () => reducers, // вернуть редьюсеры\n\n    // возвращает state!, без исключённых элементов\n    reduce: (state: RootState, action: AnyAction): CombinedState< RootReducer > => {\n      if (keysToRemove.length > 0) {\n        state = { ...state }\n        keysToRemove.forEach((key) => {\n            delete state[key]\n        })\n          \n        keysToRemove = []\n      }\n      return combinedReducer(state, action)\n    },\n\n    // Добавляет реьюсер\n    add: (key: keyof RootState, reducer: Reducer) => {\n      if (!key || reducers[key]) {\n        return\n      }\n      reducers[key] = reducer\n      combinedReducer = combineReducers(reducers)\n    },\n\n    // Удаляет реьюсер\n    remove: (key: keyof RootState) => {\n      if (!key || !reducers[key]) return\n      delete reducers[key]\n      keysToRemove.push(key)\n      combinedReducer = combineReducers(reducers)\n    }\n  }\n}\n```\n\nДалее необходимо интегрировать reducerManager в store\n```\nexport function createReduxStore(initialState?: RootState) {\n    const reducerManager = createReducerManager(defaultReducers);\n\n    const store = configureStore<RootState>({\n        reducer: reducerManager.reduce,\n        devTools: IS_DEV,\n        preloadedState: initialState,\n    });\n\n    // @ts-ignore\n    store.reducerManager = reducerManager;\n\n    return store;\n}\n```\n\nПосле чего, мы сможем вызывать в lazy-компоненте useStore, и завязать добавление\nи удаление редьюсера в useEffect\n```\nconst store = useStore() as StoreWithReducerManager;\nuseEffect(() => {\n    dispatch({ type: '@INIT authReducer' });\n    store.reducerManager.add('auth', authReducer);\n\n    return () => {\n        dispatch({ type: '@Remove authReducer' });\n        store.reducerManager.remove('auth');\n    };\n}, []);\n```\n\n! Важный момент, после этого \"сломаются\" селекторы, так как они будут искать данные, которых ещё нет.\nПоэтому их необходимо будет поправить\n```\nexport const getUsername = (state: RootState) => state?.auth?.username || '';\n```\n\n! Так же сломаются декораторы сторибука, что бы это пофиксить, необходимо создать ещё один аргумент\nдля функции создающей сторе (store.ts), сделать его необязательным, так как добавлять их руками мы будем\nтолько для тестов. \n```\nasyncReducers?: DeepPartial<ReducersMapObject<RootState>>;\n```\nВ самом декораторе создаём объект со всеми необходимыми нам редьюсерами, его придётся кастить, \nдля передачи в функцию asyncReducers as ReducersMapObject<RootState> и прокидываем в св-во провайдера\nasyncReducers.",
      "tags": []
    },
    {
      "id": 10,
      "section_id": 3,
      "title": "I18n",
      "text": "*** i18next-react ***\nЭтот пакет позволяет работать с переводами в react\n```\nnpm install react-i18next i18next --save\n```\nЕсли мы хотим определять язык и иметь возможность подгружать переводы асинхронно, необходимо установить\n```\nnpm install i18next-http-backend i18next-browser-languagedetector --save\n```\nПростейший конфиг, может находиться где угодно, и импортироваться в index.ts как import './path';\nно если мы хотим хранить переводы не в папке public/localec/ru/translation.json, то это будет необходимо прописать в конфиге (см resources)\n```\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\n\nimport Backend from 'i18next-http-backend';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport ruLang from '../../path/../ru/translation.json';\n \ni18n\n  .use(Backend)\n  .use(LanguageDetector)\n  .use(initReactI18next)\n  .init({\n    resources: {\n        ru: ruLang\n        ...\n    }\n    fallbackLng: 'en',\n    debug: true,\n\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n    }\n  });\n\n\nexport default i18n;\n```\nДалее в приложении будут доступны useTranslate и импорт сущности i18n из файла конфига,\nс помощью которых можно взаимодействовать с переводами (менять язык, переводить, вытащить текущий язык и т п)\nХук так же принимает сроку с именем файла (чанка) с переводами, по умолчанию translation.json \n```\nconst { t, i18n } = useTranslation(\"chunkName?\");\n```",
      "tags": [
        5
      ]
    },
    {
      "id": 11,
      "section_id": 5,
      "title": "EsLint",
      "text": "***ES Lint***\nESLint статически анализирует ваш код, чтобы быстро найти проблемы.\nВстроен в webstorm: Настройки->CodeStyle->ESLint\nМожно включить фикс на каждое сохранение, ищет конфиг файл, который может быть js, json, yaml\nДля запуска скрипта настройки используем:\n```\nnpm init @eslint/config\n```\nСкрипт задаст вопросы, на основе которых создаст конфиг\n```\nmodule.exports = {\n    env: {\n        browser: true,\n        es2021: true,\n    },\n    extends: [\n        'plugin:react/recommended',\n        // 'plugin:@typescript-eslint/eslint-recommended',\n        // 'plugin:@typescript-eslint/recommended',\n        'eslint-config-airbnb',\n    ],\n    parser: '@typescript-eslint/parser',\n    parserOptions: {\n        ecmaFeatures: {\n            jsx: true,\n        },\n        ecmaVersion: 'latest',\n        sourceType: 'module',\n    },\n    plugins: [\n        'react',\n        '@typescript-eslint',\n    ],\n    rules: {\n        ...правила\n    },\n    globals: {\n        __IS_DEV__: true,\n    },\n};\n```\nЗдесь мы указываем среду, для которой разрабатываем (env),\nужe готовые конфиги от которых наследуем свой (extends),\nпарсер для кода, если нужен, например, typescript и его опции (parserOptions), \nплагины помогающие eslint читать и понимать наш код (plugins),\nнаши правила, в которых можно \"перезаписать\" правила из extends конфигов (rules),\nобъявления глобальных переменных (globals),\n* все правила, как правило \"гуглятся\" и настраиваются по мере роста проекта,\nно основные лучше указать сразу.\n\n! Для того, что бы иметь возможность игнорировать unused переменные, без которых\nзачастую не обойтись, учитывая что методы и св-ва типов - unused,\nможно задать следующие правила (они отслеживают unused переменные, игнорируя типы\nи переменные именованные со знака \"_\"):\n```\n'no-unused-vars': 'off',\n'@typescript-eslint/no-unused-vars': ['error', {\n    varsIgnorePattern: '^_',\n    argsIgnorePattern: '^_',\n}],\n```",
      "tags": []
    },
    {
      "id": 12,
      "section_id": 5,
      "title": "Stylelint",
      "text": "***Stylelint***\nДля начала работы устанавливаем сам пакет и конфиг.\nЕсли работаем с css -> stylelint-config-standard,\nесли с scss -> stylelint-config-standard-scss\n```\nnpm install --save-dev stylelint stylelint-config-standard-scss\n```\nдалее создаем кофиг файл в корне проекта .stylelintrc.json \n(или JS module.exports = {...), в котором можем:\n* \"отнаследоваться\" от существующего конфига с правилами (extends)\n* добавить плагины (plugins)\n* прописать правила вручную (rules)\n```\n{\n  \"extends\": [\"stylelint-config-standard\"],\n  \"plugins\": [\"stylelint-order\"],\n  \"rules\": {\n    \"order/properties-alphabetical-order\": true\n    ...\n}\n```\n* stylelint-order - плагин позволяющий настроить порядок свойств и отступы между  группами свойств, при настройке отступов, плагин конфликтует с stylelint-config-standard-scss,\nпоэтому необходимо переназначить правило declaration-empty-line-before в null и прописать\nпорядок свойств (order/order), в объекте после массива групп (order/properties-order),\nпередаются настройки для непрописанных в (order/properties-order) правил (unspecified)\n```\n{\n  \"extends\": [\n    \"stylelint-config-standard-scss\"\n  ],\n  \"plugins\": [\n    \"stylelint-order\"\n  ],\n  \"rules\": {\n    \"indentation\": [\n      4\n    ],\n    \"selector-class-pattern\": null,\n    \"declaration-empty-line-before\": null,\n    \"order/order\": [\n      \"custom-properties\",\n      \"declarations\"\n    ],\n    \"order/properties-order\": [\n      [\n        {\n          \"groupName\": \"size\",\n          \"noEmptyLineBetween\": true,\n          \"emptyLineBefore\": \"always\",\n          \"properties\": [\n            \"width\",\n            \"height\",\n            \"margin\",\n            \"padding\"\n          ]\n        },\n        {\n          \"groupName\": \"font\",\n          \"noEmptyLineBetween\": true,\n          \"emptyLineBefore\": \"always\",\n          \"properties\": [\n            \"font-family\",\n            \"font-size\",\n            \"font-weight\",\n            \"letter-spacing\",\n            \"line-height\",\n            \"color\"\n          ]\n        }\n      ],\n      {\n        \"unspecified\": \"bottom\",\n        \"emptyLineBeforeUnspecified\": \"always\"\n      }\n    ]\n  }\n}\n```",
      "tags": []
    },
    {
      "id": 13,
      "section_id": 6,
      "title": "Jest",
      "text": "***Jest (Get started, TS, React)***\nJest - это не только набор функций для тестирования JS (describe, it, expect), \nно в первую очаредь тестовая среда, платформа которая обеспечивает окружение для работы с тестами\nделает видимыми Api тестовых библиотек в окружении приложения.\n\nДля начала настройки окружения, устанавливаем Jest, отвечая на вопросы.\n```\njest --init\n```\nВажно помнить, что Jest не знает как работать с TypeScript, поэтому, для тестирования TS кода, нам\nнеобходимо преобразовать код с помощью компилятора, Jest работает с Babel. Для работы в среде React/TS,\nставим 3 пресета, для Babel.\n```\nnpm i -D @babel/preset-env @babel/preset-typescript @babel/preset-react\n```\nв webpack.rules добавлять не нужно, далее качаем типы для Jest, но для корректной работы Jest c React\nпосле установки пресетов Babel, нужно передать опцию для @babel/preset-react -> { runtime: 'automatic' },\nбез этого React не попадёт в тестовое окружение.\n\nТак же для самого Jest ставим типы\n```\nnpm install --save-dev @types/jest\n```\nПосле этого, если мы хотим тестировать React компоненты, нужно установить тестовую среду, это \nпередаётся в конфиге, в соответствующей строке, по умолчанию node.js (браузер - jsdom)\n! С 28 версии Jest - окружение jsdom ставится как отдельный пакет - jest-environment-jsdom\n\nТак же сразу необходимо указать:\n* автоматическую отчистку mock-ов после каждого теста (clearMocks)\n* путь к корневой директории (rootDir),\n* регулярку для определения файлов с тестами (testMatch),\n* директории игнорируемые тестами (testPathIgnorePatterns),\n* массив расширений файлов (moduleFileExtensions)\n```\n    clearMocks: true,\n\n    rootDir: '../../',\n\n    testMatch: [\n        '<rootDir>src/**/*@(spec|test).[tj]s?(x)'\n    ],\n\n    testPathIgnorePatterns: [\n        \"\\\\\\\\node_modules\\\\\\\\\"\n    ],\n\n    testEnvironment: 'jsdom',\n\n    moduleFileExtensions: [\n        'js',\n        'jsx',\n        'ts',\n        'tsx',\n        'json',\n        'node',\n    ],\n```\n***Расширение возможностей Jest***\nМы имеем возможность расширять функционал нашей тестовой среды, например за счёт вспомогательных\nпакетов, таких как [@testing-library/react](), который легко интегрируется с Jest (просто скачивается).\nНо мы так-же можем расширять тестовые инструменты с помощью setupTest файла, в который импортируем доп\nпакеты (например @testing-library/jest-dom), а путь к данному файлу указываем в jest.config \n```\nsetupFilesAfterEnv: [\n    path.resolve(__dirname, 'setupTests.ts'),\n],\n```\n***Отчёт о покрытии (coverage)***\nБудет полезным периодически просматривать процент покрытия тестами, для настройки данной функции \nнеобходимо, указать в конфиге:\n* куда расположить информацию о покрытии (coverageDirectory)\n* какие директории игнорировать при оценке покрытия (coveragePathIgnorePatterns)\n```\ncoverageDirectory: '<rootDir>config/jest/coverage',\n\ncoveragePathIgnorePatterns: [\n        \"\\\\\\\\node_modules\\\\\\\\\"\n\n    ],\n```\nПосле этого запустить тесты с флагом --coverage\n```\njest --config ./config/jest/jest.config.ts --coverage\n```\n***Работа с модулями и импортами Jest***\nЗачастую нам необходимо импортировать assets файлы (изображения, шрифты, mp3 и т п),\nно Jest не может работать с webpack импортами из коробки, настроить пути для импорта модулей \nнам поможет поле в конфигурации moduleNameMapper, в это поле мы можем замокать, пути для импортов\nзамокать можно:\n* для файлов пустым имортом module.exports = {} или module.exports='test-file-stub' \nСам Jest рекомендует строку test-file-stub. Так же на импорт с определённым расширением можно\nвозвращать определённый компонент (хелпер), как заглушку.\n* для модулей файлом в папке __mocks__ или файлом (может быть компонентом пример: react-markdown)\n* для стилей пустым имортом module.exports = {} или module.exports='identity-obj-proxy' \nСам Jest рекомендует identity-obj-proxy, для эфективной работы с css-modules (пакет)\n\n! Так же в этом блоке указываются алиасы, используемые в приложении, по примеру .tsconfig\n* ключ - это регулярка для определения алиаса (импорта) 'I18n/(.*)'\n* значение - это путь, которым подменяем алиас (где $1 - заменяет *, то есть все файлы директории)\n```\nmoduleNameMapper: {\n        '\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$': path.resolve(__dirname, '__mocks__', 'fileMock.ts'),\n        '\\\\.(css|scss)$': path.resolve(__dirname, '__mocks__', 'styleMock.ts'),\n        '\\\\.svg$': path.resolve(__dirname, 'testHelpers', 'MockSvgComponent.tsx'),\n        'react-markdown': path.resolve(__dirname, 'testHelpers', 'ReactMarkdown.tsx'),\n        'I18n/(.*)': '<rootDir>src/lib/i18n/config/$1',\n    }\n```",
      "tags": []
    },
    {
      "id": 14,
      "section_id": 6,
      "title": "React testing library",
      "text": "***Testing library***\n@testing-library - предоставляет инструменты для упрощения тестирования рендера компонентов\nеё пакет @testing-library/react - это специализированный инструмент для react приложений,\nон создаёт абстракцию над react-dom и react-dom/test-utils давая более простое и гибкое API.\nУстановка при работе с Jest не требует дополнительных настроек конфигурации:\n```\nnpm install --save-dev @testing-library/react\n```\nОсновные функции пакета, доступные в тестовой среде после установки:\n* render - позволяет произвести монтирование компонента с параметрами\n* waitFor - позволяет дождаться \"промис\"\n* expect - функция Jest, но мы можем расширить её возможности с помощью доп. пакетов,\nподключаемых через testSetup файл в Jest (например @testing-library/jest-dom, добавляющая\nмножество удобных способов проверки toBeInTheDocument, toHaveClass и т п)\n* fireEvent - позволяющая прокинуть изолированное конкретное событие на элемент\n* userEvent - ставится как отдельный пакет @testing-library/user-event @testing-library/dom\nи позволяет полностью воссоздать событие на элементе в среде браузера, например onClick,\nэто последовательно вызванные mousedown -> mouseup -> onclick\n* screen - даёт возможность добраться до узлов и получить из них данные\nи имеет 3 типа селекторов:\n    1) getBy... - возвращает элемент или ошибку, если элемент не найден\n    2) queryBy... - возвращает элемент или null, если элемент не найден\n    3) findBy... -  возвращает \"промис\" с результатом\nи их версии с All\n    1) getAllBy... - возвращает массив элементов или ошибку, если элементы не найдены\n    2) queryAllBy... -  возвращает массив элементов или [], если элементы не найдены\n    3) findAllBy... -  возвращает \"промис\" с результатом (массивом элементов или ошибкой)",
      "tags": []
    },
    {
      "id": 15,
      "section_id": 6,
      "title": "Storybook",
      "text": "***Storybook***\nStorybook - это витрина компонент, позволяющая изучить вынесенные компоненты,\nих параметры, увидеть как они отображаются на UI и совершать скриншотное тестирование.\n\nДля установки storybook, запускаем скрипт в корне проекта\n```\nnpx storybook init\n```\n! Есть различия при использовании разных сборщиков, если используем webpack5\n```\nnpx sb init --builder webpack5\n```\n\nДалее в корне появится директория .storybook, в которой будут содержаться 2 файла\n* main.js - основной конфиг (плагины, регулярка отбора файлов, пути к директориям)\n* preview.js - конфирурация историй (параметры отображения, декораторы)\n\nПеремещая конфиг, необходимо указать в скрипте запуска тестов новый путь с флагом -c\nбудет искать main.js, в котором тоже нужно не забыть поправить пути. \n```\n\"storybook\": \"start-storybook -p 6006 -c ./config/storybook\"\n```\n\nВажно понимать, что сама винтрина, разворачивается на localhost с помощю webpack,\nто есть под капотом зашит дефолтный конфиг, и все наши дополнения вряд ли будут работать\nпо-умолчанию, для настройки сборки сторибука ужно изменить его webpack.config, сделать это\nможно 2-я способами:\n1) Передать в main.js в свойство webpackFinal, функцию, принимающую и возвращающую кофиг\n```\n webpackFinal: async (config, { configType }) => {\n    config.resolve.alias = {\n    \t\"UI\": \"src/path/ui\"\n    }\n    return config;\n  },\n```\n\n2) Создать рядом с main.js свой файл webpack.config, функция которая так же принимает конфиг\nи возвращает конфиг.\n```\nexport default ({config}: {config: webpack.Configuration}): webpack.Configuration => {\n    return config;\n}\n```\nПо факту, сюда необходимо прописать алиасы, лоадеры и другие настроики вашей сборки необходимые\nдля корректного отображения компонент.\n\n***Decorators***\nТак же для корректного отображения компонент им требуются контексты (StoreProvider, i18n, стили)\nв этом нам могут помочь декораторы. Это функции, принимающие и возвращающие Story. Использовать\nэтот аргумент мы можем и как функцию и как компонент.\n```\nexport const StyleDecorator = (story: () => Story) => story();\nexport const ThemeDecorator = (theme: Theme) => (StoryComponent: Story) => {\n    return <div className={`app ${theme}`}><StoryComponent /></div>\n};\n```",
      "tags": []
    },
    {
      "id": 16,
      "section_id": 6,
      "title": "Loki",
      "text": "***Loki***\nЛоки позволяет снимать скриншоты со страниц Storybook, для его установки пишем\n```\nnpm i -D loki\n```\nДалее из корня запускаем init, если файл main.js с конфигурацией Storybook не в корне\nнужно указать к нему путь.\n```\nnpx loki init --config ./config/storybook/\n```\n\nВ package.json появится основная конфигурация Loki, в ней задаются типы устройств,\nразмеры экранов, для которых нужно сделать скриншоты. Так же нужно обратить внимание на \nсвойство target, это окружение в котором будут проводиться тесты (chrome.docker - докер,\nchrome.app - браузер), соответственно при запуске тестов он будет искать процесс таргетной\nпрограммы. Настраивать докер не нужно. Достаточно просто запустить.\n```\n\"loki\": {\n    \"configurations\": {\n      \"chrome.laptop\": {\n        \"target\": \"chrome.docker\",\n        \"width\": 1366,\n        \"height\": 768,\n        \"deviceScaleFactor\": 1,\n        \"mobile\": false\n      }\n    }\n  }\n```\nКоманды доступные с cli\n* loki test - сделать скриншоты, СРАВНИТЬ с эталонами\n* loki update - сделать скриншоты, ЗАМЕНИТЬ эталонамы\n* loki approve - обновить эталоны новыми файлами\n\nДля прогона в CI, в окружении должен быть докер. Сначала необходимо создать билд storybook.\nДалее запустить loki передав ему флаги --requireReference? и --reactUri - путь к билду storybook\n```\nbuild-storybook && loki --requireReference --reactUri file:./storybook-static\n```",
      "tags": []
    },
    {
      "id": 17,
      "section_id": 4,
      "title": "Redux Thunk test",
      "text": "###Тестирование Asynk Thunk Redux-Toolkit###\nДля тестирования асинхроных санок необходимо замокать модуль, который отвечает за запросы,\nв нашем примере axios. \nРазница м/у jest.mock и jest.mocked заключается в том, jest.mock - мокает модуль и его методы,\nа jest.mocked типизирует дерево модуля, что позволяет использовать его с TypeScript.\n```import axios from 'axios';\n\njest.mock('axios');\n\nconst mockedAxios = jest.mocked(axios);\n\nmockedAxios.get.mockReturnValue(Promise.resolve(CUSTOM_VALUE));\n```\nЕсли наш axios используется через инстанс, проще всего будет мокать уже сам инстанс.\n```import { instanceAxios } from \"../../../../../../../api\";\n\njest.mock('../../../../../../../api');\n\nconst mockedAxios = jest.mocked(instanceAxios);\n\nmockedAxios.get.mockReturnValue(Promise.resolve(CUSTOM_VALUE));\n```\nВ целом, тест get запроса санки выглядит следующим образом, где мы (по-шагам):\n1) Мокаем наш api(axios) использующийся внутри санки.\n2) Мокаем dispatch и getState - эти функции далее необходимо будет передать в action\n3) Задаём целевому методу (в нашем случае get), возвращаемое значение mockReturnValue\n4) Вызываем санку, она возвращает action, но так как данный actionCreator отрабатывает \nthunk-middleware к нам возвращается функция, ожидающая на вход dispatch, getState и thunkConfig\n5) Диспатчим action (fetchIncidentAction) в thunk-middleware, получаем результат в payload, \nесли не вручную, обычно за нас это сделает обёртка в dispatch(...), такой подход позволяет\nпроверять, сколько раз и с какими аргументами был вызван dispacth.\n6) Получаем результат, который содержит payload и meta данные\n```import { fetchIncident } from \"./fetchIncident\";\nimport { instanceAxios } from \"../../../../../../../api\";\nimport type { RootState } from \"../../../../../../../store/store\";\nimport type { Incident } from \"../../../types/IncidentCardLayout.types\";\nimport type { Dispatch } from '@reduxjs/toolkit';\n\nlet dispatch: Dispatch;\nlet getState: () => RootState;\n\njest.mock('../../../../../../../api');\n\nconst mockedAxios = jest.mocked(instanceAxios);\n\ndescribe('fetchIncident', () => {\n    beforeEach(() => {\n        dispatch = jest.fn();\n        getState = jest.fn();\n    });\n\n    it('should be return incident', async () => {\n        mockedAxios.get.mockReturnValue(Promise.resolve({data: incident}));\n\n        const fetchIncidentAction = fetchIncident(1);\n\n        const result = await fetchIncidentAction(dispatch, getState, undefined);\n\n        expect(result.meta.requestStatus).toBe('fulfilled');\n        expect(result.payload).toEqual(incident);\n    });\n});```",
      "tags": []
    },
    {
      "id": 18,
      "section_id": 3,
      "title": "Методы жизненного цикла",
      "text": "###Жизненый цикл###\n***Жизненный цикл установки компонента***\n* constructor(props) - getInitialState() - вызывается при создании компонента \n\tАналог в FC: логика в теле функции компонента при её вызове, useLayoutEffect\n* componentWillMount() - вызывается до отображения в DOM\n\tАналог в FC: логика в теле функции компонента при её вызове\n* render() - render() - рендер JSX\n\tАналог в FC: return который возвращает JSX\n* componentDidMount() - вызывается при вмонтировании компонента\n\tАналог в FC: useEffect c пустыми зависимостями []\n* componentWillUnmount()- вызывается перед удалением с экрана\n\tАналог в FC: useEffect блок return у useEffect с пустыми зависимостями []\n\nВмонтирование: \n\tgetInitialState(useLayoutEffect) -> \n\tcomponentWillMount(логика в теле функции компонента) ->\n\trender(return) ->\n\tcomponentDidMount(useEffect[]) ->\n\tПри уничтожении компонента componentWillUnmount(useEffect блок return)\n\n***Жизненный цикл обновления***\n* componentWillReceiveProps(nextProps) — вызывается только в случае передачи компоненту \n    новых свойств; единственный метод, в котором может быть вызван метод setState;\n\tАналог в FC: useEffect с отслеживаемым пропсом в зависмимости [prop]\n* shouldComponentUpdate(nextProps, nextState) — привратник (перед) жизненного цикла обновления: \n\tпредикат, способный отменить обновление; может использоваться для повышения производительности, \n\tразрешая только необходимые обновления;\n\t\tАналог в FC: React.memo или useMemo\n* componentWillUpdate(nextProps, nextState) — вызывается непосредственно перед обновлением компонента;\n\t похож на метод componentWillMount, но вызывается только перед выполнением каждого обновления;\n\t\tАналог в FC: нет аналога, так как useEffect асинхроный и выполняется после рендера\n* componentDidUpdate(prevProps, prevState) — вызывается сразу же после выполнения обновления, \n\tпосле вызова метода отображения render; похож на метод componentDidMount,\n\tно вызывается только после каждого обновления.\n\t\tАналог в FC: useEffect без зависимостей\n\nОбновление:\n\tshouldComponentUpdate(React.memo или useMemo) ->\n\tcomponentWillReceiveProps(useEffect[prop]) -> \n\trender(return) ->\n\tcomponentDidUpdate(useEffect без зависимостей)",
      "tags": []
    },
    {
      "id": 19,
      "section_id": 3,
      "title": "Основные возможности React",
      "text": "###Основные возможности###\n\n1) Доступность (стандарт a11y)\n\t- Семантическая вёрстка\n\t- Таб инексы, атрибуты тэгов (alt=\"\")\n\t- Label для всех inputs\n\t- Адекватная информация об ошибках\n\n2) Разделение кода - достигается с помощю webpack\n\t- import/export - разделения на компоненты и модули\n\t- Лези лоадинг, позволяющий подгружать только необходимые файлы\n\t\tconst Copm = React.lazy(() => import('./Component'))\n\t\t<Suspense fallback={<div>Load...</div>}><Comp /></Suspense>\n\n3) Контекст - необходим для хранения глобальных данных, создается независимо\n```\n//получает значение, при инициализации Provider\nconst ThemeContext = React.createContext({})\n\n< ThemeContext.Provider value=\"dark\" >\n       < Comp />\n < /ThemeContext.Provider >\n\t\t\n// Внутри конф обращаемся либо через Consumer либо useContext\n< MyContext.Consumer >\n  \t{value => /* отрендерить что-то, используя значение контекста */}\n< /MyContext.Consumer >\n```\n\n4) Предохранители - Error Boundary - классовый компонент высшего порядка (HOC), имеющий 2\n\tобязательных метода: static getDerivedStateFromError возвращающий { hasError: true }\n\tустанавливает ошибку, и тем самым выводит \"запасной\" JSX. \n\tcomponentDidCatch - срабатывает после получения ошибки, в нём можно сделать\n\tасинхронные операции или залогировать ошибку.\n```\nexport class ErrorBoundary extends React.Component< Props, State > {\n    constructor(props: Props) {\n        super(props);\n        this.state = { hasError: false };\n    }\n\n    static getDerivedStateFromError(_: Error) {\n        return { hasError: true };\n    }\n\n    componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n        // eslint-disable-next-line no-console\n        console.log('[Error boundary]', error.name, error.message, errorInfo);\n    }\n\n    render() {\n        const { hasError } = this.state;\n        const { children } = this.props;\n\n        if (hasError) {\n            return <Suspense fallback={< Loader />}>< ErrorScreen />< /Suspense >;\n        }\n\n        return children;\n    }\n}\n```\n\n5) Перенаправление рефов - React.forwardRef((props, ref) => {...Component})\n\tforwardRef - HOC, позволяющий передать объект ссылки через props\n\n6) Фрагменты < React.Fragment /> || < > < \\> \n\n7) HOC - функция которая принимает Компонент, а возвращает новый компонтент обёртку, который\n\tдобавляет переданному функционал или данные(через пропсы).\n\n8) Сторонние библиотеки - экосистема React (Формы, Роуты, Тесты, Билд Тулс, Линтеры и т д)\n\n9) JSX - \"HTML внутри JS\" - придуманый в Facebook способ разметки\n\n10) Оптимизация\n\tОптимизации сборок достигаются минификацией бандлов, в webpack это TerserPlugin \n\t- для prod сборки и fork-ts-checker-webpack-plugin для dev с TypeScript (отключает\n\tпроверку TypeScript компиляции) Так же рекомендуется убрать SourceMap из prod сборки\n\tСюда же можно отнести процесс сравнения VDOM (Reconcilation), встроеный способ \n\tсравнения изменений, позволяющий не перерисовывать не изменившиеся узлы + Memo\n\n11) Порталы\n\t- Api ReactDOM, позволяющий вмонтировать элемент в указанный узел DOM,\n\t\t* ReactDOM.createPortal(child, container)\n\n12) Profiler - измеряет то, как часто рендерится React-приложение и какова «стоимость» этого.\n\tЕго задача — помочь найти медленные части приложения, которые можно оптимизировать \n\t(например, через мемоизацию). Компонент Profiler - оборачивает тестируемый компонент, \n\tпринимает в пропсы id и onRender - обработчик в который придут данные, о компоненте.\n\n13-14) React без ES6 - React без JSX\n\t- createReactClass() - функция из спец пакета, позволяла создать класс React\n\t- React.createElement(elem, attr, children) - создать элемент\n\t- React.createFactory(type) - dозвращает функцию, которая создаёт элементы React \n\tзаданного типа(type) Аналог: .map((item)).\n\n15) Согласование (Reconsilation) - процесс сравнения VDOM элементов, и списков. Улучшается\n\tFacebook.\n\n16) Ref и DOM - рефы необходимы для императивного взаимодействия с DOM, управления фокусом и\n\tанимациями. React.createRef() - создаёт объект ссылки, нельзя использовать с \n\tфункциональными компонентами, потому что для них не создаётся экземпляр класса, Ref.\n\tЕсли необходимо передать реф в функциональный компонент, нужно возпользоваться HOC \n\tReact.forwardRef - он дополняет пропсы слотом для объекта ref.\n\n17) Render prop\nРодитель: Компонент, запрашивает данные, и возвращает функцию (компонент ребёнок): \n* переданную в пропсы\n```\n// В родителе: \nreturn < Child render={(data) => <Child data={data} />}) />\n\n// В ребёнке: \nreturn render(data)\n```\n* или обёрнутую как children\n```\n// В родителе: \nreturn < Parent >\n\t(data) => \n\t\t< Child data={data} />\n\t}\n</Parent>\n// В ребёнке\nreturn children(data)\n\n```\n18) Типизация - основная TypeScript\n\n19) Strict mode - добавляет дополнительные проверки для потомков\n\n20) Prop Types - ранее метод React.Component - добавляющий возможность типизировать пропсы,\n\tсейчас отдельная библиотека.\n\n21) Controled/Uncontroled components - концепция контролируемых и не контролируемых компонент.\n\n22) Web-components - отдельная тема для разговора, тег наследуемфый от класса JS - HTMLElement\n\t- с его функционалом и методами жизненного цикла.",
      "tags": []
    },
    {
      "id": 20,
      "section_id": 7,
      "title": "Основные команды Linux",
      "text": "###Часто используемые команды Linux###\n***echo*** \"string\" - отображаeт строку текста (флаг -e позволяет определять спец символы)\n\n***cat*** - вычитывает текст файла и направляет его в поток вывода (по-умолчанию консоль),\nможно направить в другую команду.\n\n* cat \"Some text\" > text.txt - создаст файл вычитывает текст \"Some text\" и поместит его в файл,\nсоздав его, если таковой отсутствует или перезаписав данные если файл существовал.\n\n* cat \"Some text\" >> text.txt - создаст файл вычитывает текст \"Some text\" и и дополнит в файл.\n\n***less***- вычитывает текст файла и выводит его в консоль в размер окна с возможностью прокрутки.\n\n***more*** - вычитывает текст файла и выводит его в консоль в размер окна с указанием процента\nпоказанного текста и возможностью постраничного вывода.\n\n***editor***< filename > - открывает файл в редакторе nano/vim (по-умолчанию nano)\n\n***find < dir > < options > < template >*** - позволяет искать файлы по шаблону поиска,\ndir - директория поиска, template - строковый шаблон для поиска, options - по какому полю\nискать, чаще всего используют -name\n\n* find /etc -name \"hosts*\" - найти в директории etc все файлы, имя которых начинается с hosts\n\n***grep < options > < template > < file >*** - позволяет найти строку в файлах, template - строковый шаблон\nдля поиска, options - , при выборе директории в file, передаём -r, для рекурсивного поиска во всех\nфайлах директории, file - директория или файл для поиска\n\n* grep -r \"text\" /home/user/Desktop - найти совпадения со строкой \"text\" в файлах на рабочем столе",
      "tags": []
    },
    {
      "id": 21,
      "section_id": 8,
      "title": "html/template",
      "text":"###net/http###\nПакет http предоставляет реализации клиента-серверного HTTP взаимодействия.\n\n***Статические методы***\n***CanonicalHeaderKey*** - форматирует переданное имя заголовка в каноничный формат,\n(Первая и каждая буква после дефиса - заглывные, остальные - строчные)\n```\nfunc CanonicalHeaderKey(s string) string\n```\n\n***DetectContentType*** - принимает массив байт и возвращает тип MIME. \nЕсли он не может определить более конкретный тип, он возвращает «application/octet-stream».\n```\nfunc DetectContentType(data []byte) string\n```\n\n***Error*** - отвечает на запрос ошибкой.\n```\nfunc Error(w ResponseWriter, error string, code int)\n```\n\n***Handle*** - ???\n\n***HandleFunc*** - регистрирует обработчик, для обслуживания эндпоитна pattern\n```\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request))\n```\n\n***ListenAndServe*** - начинает \"слушать\" запросы на порту addr (TCP).\nЕсли обработчики были зарегестрированны через Handle или HandleFunc в handler можно \nпередать nil,\n```\nfunc ListenAndServe(addr string, handler Handler) error\n```\n\n***ListenAndServeTLS*** - ListenAndServeTLS действует так же, как ListenAndServe,\nза исключением того, что он ожидает соединения HTTPS. Кроме того, должны быть\nпредоставлены файлы, содержащие сертификат и соответствующий закрытый ключ для сервера.\nЕсли сертификат подписан центром сертификации, certFile должен быть конкатенацией \nсертификата сервера, любых промежуточных звеньев и сертификата ЦС.\n```\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error\n```",
      "tags": []
    },
    {
      "id": 22,
      "section_id": 8,
      "title": "net/http",
      "text": "###html/template###\nПакет реализует управляемые данными шаблоны для создания вывода HTML, защищенного от внедрения кода.\nОн предоставляет тот же интерфейс, что и текст/шаблон пакета, и его следует использовать вместо \ntext/template всякий раз, когда вывод представляет собой html.\n\n***template.New(name string) *Template*** - возвращает указатель на ИНСТАНС html-шаблона, добавляее ему\nимя name (БЕЗ САМОГО HTML), для добавления html у *Template есть метод Parse(html string)...\n```\nvar instance, err = template.New(\"main\")\n```\n\n***template.Must(t *Template, err error) *Template*** - вспомогательный метод, оборачивает создание instance.\nОбрабатывает ошибку (кидает панику), что позволяет более лаконично создать instance html-шаблона\n```\nvar instance = template.Must(template.New(\"name\").Parse(\"html\"))\n```\n\n***func ParseFiles(filenames ...string) (*Template, error)*** - позволяет прочитать несколько html файлов и \nсоздать из них шаблон с именем первого файла переданного в аргументы\n```\nvar instance, err = template.ParseFiles(\"layout.html\", \"main.html\")\n```\n\n***Методы экземпляра***\n*** * Name*** - возвращает имя шаблона.\n```\nfunc (t *Template) Clone() (*Template, error)\n```\n\n*** * Clone*** - возвращает копию экземпляра, включая все связанные шаблоны.\n```\nfunc (t *Template) Clone() (*Template, error)\n```\n\n*** * Delims*** - определяет символы для экранирования в шаблоне. \nПо умолчанию: left = \"{{\" , right=\"}}\"\n```\nfunc (t *Template) Delims(left, right string) *Template\n```\n```\nconst text = \"<<.Greeting>> {{.Name}}\"\n\ndata := struct {\n  Greeting string\n  Name     string\n}{\n  Greeting: \"Hello\",\n  Name:     \"Joe\",\n}\n\nt := template.Must(template.New(\"tpl\").Delims(\"<<\", \">>\").Parse(text)) // Output: Hello {{.Name}}\n```\n\n*** * Execute*** - применяет шаблон к указанному объекту данных, writer, который может иметь тип:\nhttp.ResponseWriter - при обработке ответа http\nio.Writer - при необходимости вывода шаблона в консоль (или в поток вывода) \n\nА аргумент data - это структура, к которой из шаблона можно обращаться через точку {{ . }}\nСоответственно её свойства и методы {{ .Name }} {{ .Method() }}\n\n```\nfunc (t *Template) Execute(writer io.Writer, data any) error\n```\n```\nerr := templateInstanse.Execute(writer, data)\nif err != nil {\n  log.Fatal(err)\n}\n```",
      "tags": []
    },
    {
      "id": 23,
      "section_id": 8,
      "title": "builtin",
      "text": "###builtin###\nЯвляется пакетом, содержащим все основные типы и вспомагательные функции Go.\nДоступен в файлах .go без явного импорта.\n\n***Константы***\n***true*** - логическая правда\n\n***false*** - логическая ложь\n\n***iota*** - имплементируемое значение выраженное целыми числами, начиная с 0\n```\nconst (\n    C1 = iota\n    C2\n    C3\n)\nfmt.Println(C1, C2, C3) // \"0 1 2\"\n```\n\n***Функции***\n***append*** - добавляет в конец слайса новый элемент(или слайс с тем же типом элементов).\nЕсли у слайса в который добавляются элементы достаточно вместимости (capacity), то \nэлемент(-ы) добавляются в него и возвращается он же, но увеличенный. Если же нет,\nто создаетcя новый массив с большей вместимостью и в него помещаются все элементы, \nпосле чего он возвращается.\n\nelems - могут быть значениями через запятую или слайсом значений.\n```\nfunc append(slice []Type, elems ...Type) []Type\n```\n\n***cap*** - возвращает ёмкость\n```\nfunc cap(v Type) int\n```\n\n***close*** - закрывает  Встроенная функция close закрывает канал, который должен быть \nдвунаправленным или только для отправки.\n```\nfunc close(c chan<- Type)\n```\n\n***complex*** - создаёт комплексное значение из 2-х float.\nАргументы должны иметь одинаковый тип float, если он float32, то возращаемое \nзначение complex64, а если float64, то возвращаемое complex128.\n```\nfunc complex(r, i FloatType) ComplexType\n```\n\n***copy*** - копирует елементы слайса from в слайс to, возвращает количесво \nскопированных элементов. Если длинна слайсов разная (len), копируется количество\nэлементов равное минимальной длинне из 2-х.\n```\nfunc copy(to, from []Type) int\n```\n\n***delete*** - удаляет из Мапы значение по ключу, если m == nil, или элемента\nне существует, удаление не выполняется.\n```\nfunc delete(m map[Type]Type1, key Type)\n```\n\n***len*** - возвращает длинну аргумента\n```\nfunc len(v Type) int\n```\n\n***make*** - создает только срезы, карты и каналы. Возвращает ЗНАЧЕНИЕ типа\nType(тип данных), а не указатель на инициализированную память *T как new().\n```\nfunc make(t Type, size ...IntegerType) Type\n```\n\n***new*** - иницилизирует область в памяти для значение переданного типа Type.\nРаботает для всех типов данных (кроме канала, карты) и динамически выделяет \nместо для переменной этого типа, инициализирует ее нулевым значением этого типа\nи возвращает указатель на нее.\n```\nfunc new(Type) *Type\n```\n\n***panic*** - данная функция возвращает необработанную ошибку выполнения \nпрограммы и останавливает её выполнение. В поток вывода выводится сообщение,\nв котором указывается горутина, в которой произошла ошибка, сообщение v,\nи трассировка стека, указывающая в каком файле и в какой строке ошибка.\nВАЖНО!: отложенные функции (defer), запускаются даже после паники, там можно\nиспользовать функцию recover, для востановления.\n```\nfunc panic(v any)\n```\n\n***real*** - возвращает реальную чать комплексного числа.\n```\nfunc real(c ComplexType) FloatType\n```\n\n***recover*** - \n```\nfunc recover() any\n```\n```\n//main ВЫВЕДЕТ: Recovered. Error: ERROR TEXT\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"Recovered. Error:\\n\", r)\n        }\n    }()\n\t\n    panic(\"ERROR TEXT\")\n\n    fmt.Println(\"After panic\") // Не выполнится\n}\n```\n\n\n***print, println*** - Встроенные функции печати не гарантируется, \nчто они останутся в языке. Лучше не использовать, заменить на \"fmt\"\n```\nfunc print(args ...Type)\nfunc println(args ...Type)\n```\n\n***Типы***\n***ComplexType*** - тип для документации complex64 или complex128\n```\ntype ComplexType complex64\n```\n\n***FloatType*** - тип для документации float32 или float64\n```\ntype FloatType float32 \n```\n\n***IntegerType*** - тип для документации int, uint, int8 (числовые)\n```\ntype IntegerType int\n```\n\n***Type, Type1*** - тип для документации обозначают любой тип Go\n```\ntype Type int\nfunc delete(m map[Type]Type1, key Type)\n```\n\n***any*** - интерфейс, который ничего не должен реализовывать (любой)\n```\ntype any = interface{}\n```\n\n***bool*** - логический тип\n```\ntype bool bool\n```\n\n***byte*** - то же что и uint8, нужен что бы отличить байтовые значениями\nот 8-битных целых чисел, псевдоним для uint8\n```\ntype byte = uint8\n```\n\n***comparable*** - интерфейс который определяет типы которые могут быть\nсравнены с помощью == и != от 8-битных целых чисел\n```\ntype comparable interface{ comparable }\n```\n\n***complex128*** - комплексные числа с действительными и мнимыми\nчастями типа float64\n```\ntype complex128 complex128\n```\n\n***complex64*** - комплексные числа с действительными и мнимыми\nчастями типа float32\n```\ntype complex64 complex64\n```\n\n***float32*** - числа с плавающей точкой, размером до 32 бит\n```\ntype float32  float32 \n```\n\n***float64*** - числа с плавающей точкой, размером до 64 бит\n```\ntype float64  float64 \n```\n\n***int*** - целые числа со знаком, размером до 32 бит\n```\ntype int int \n```\n\n***int8*** - целые числа со знаком, размером до 8 бит\nОт -128 до 127\n```\ntype int8  int8  \n```\n\n***int16*** - целые числа со знаком, размером до 16 бит\nОт -32768 до 32767\n```\ntype int16  int16  \n```\n\n***int32*** - целые числа со знаком, размером до 32 бит\nОт -2147483648 до 2147483647\n```\ntype int32 int32 \n```\n\n***int64*** - целые числа со знаком, размером до 32 бит\nОт -9223372036854775808 до 9223372036854775807\n```\ntype int64 int64 \n```\n\n***rune*** - аналог int32, но используется используется по соглашению,\nчтобы отличить символьные значения от целых значений.\nПредставляет Unicode код\n```\ntype rune = int32\n```\n\n***string*** - строка, последовательный набор байт (иммутабельный)\n```\ntype string string\n```\n\n***uint8*** - положительные целые числа со знаком, размером до 8 бит\nОт 0 до 255\n```\ntype uint8  uint8  \n```\n\n***uint16*** - положительные целые числа со знаком, размером до 16 бит\nОт 0 до 65535\n```\ntype uint16  uint16  \n```\n\n***uint32*** - положительные целые числа со знаком, размером до 32 бит\nОт 0 до 4294967295\n```\ntype uint32 uint32 \n```\n\n***uint64*** - положительные целые числа со знаком, размером до 64 бит\nОт 0 до 18446744073709551615\n```\ntype uint64 uint64 \n```\n\n***uintptr*** - это целочисленный тип, достаточно большой для хранения\nбитовой комбинации любого указателя.\n```\ntype uintptr uintptr\n```",
      "tags": []
    },
    {
      "id": 24,
      "section_id": 9,
      "title": "Лексические элементы",
      "text": "###Лексические элементы###\n\n***Комментарии***\n***//*** text - строчные\n***/* text */*** - блочные\n\n***Ключевые слова (keyword)***\n\n***package*** - оператор объявления пакета\n***import*** - оператор импорта\n***var*** - оператор объявления переменной\n***const*** - оператор объявления константы\n\n***if*** - условный оператор\n***else*** - часть условного оператора\n\n***for*** - оператор цикла\n***range*** - позволяет итерироваться по мапам, массивам, слайсам и строкам(символы)\n***break*** - позволяет прервать выполнение цикла for или конструкции switch\n***continue*** - позволяет прервать текущую итерацию цикла for\n\n***switch*** - оператор конструкции свитч/кейс\n***case*** - кейс для switch\n***fallthrough*** - прокидывает управление в след case текущего switch\n***default*** - значение по умолчанию для switch\n\n***func*** - объявление функции\n***return*** - возращаемое функцией значение\n\n***type*** - оператор объявления типа\n***chan*** - оператор для создания канала\n***map*** -  - ключевое слово для создания мапы\n***struct*** - ключевое слово для создания структуры\n***interface*** - ключевое слово для создания интерфейса\n\n***go*** - выносит выполнение кода в отдельную горутину\n***goto*** - позволяет перейти к метке name:\n***defer*** - оператор позволяет запустить код после завершения род. функции \n***select*** - визуально как свитч/кейс позволяет ожидать операций с несколькими каналами",
      "tags": []
    }
  ],
  "tags": [
    {
      "id": 1,
      "title": "build"
    },
    {
      "id": 2,
      "title": "ui"
    },
    {
      "id": 3,
      "title": "config"
    },
    {
      "id": 4,
      "title": "webpack"
    },
    {
      "id": 5,
      "title": "react env"
    }
  ]
}
