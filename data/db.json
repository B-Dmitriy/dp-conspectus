{
  "users": [
    {
      "id": 1,
      "name": "Dmitriy",
      "password": "123"
    }
  ],
  "catalogs": [
    {
      "id": 1,
      "title": "Frontend",
      "description": "Конспекты по основным UI технологиям и библиотекам"
    },
    {
      "id": 2,
      "title": "Internet",
      "description": "Общие сведения о работе сети"
    }
  ],
  "sections": [
    {
      "title": "Webpack",
      "catalog_id": 1,
      "id": 1
    },
    {
      "title": "Babel",
      "catalog_id": 1,
      "id": 2
    },
    {
      "title": "React",
      "catalog_id": 1,
      "id": 3
    },
    {
      "title": "Redux",
      "catalog_id": 1,
      "id": 4
    },
    {
      "title": "Code style",
      "catalog_id": 1,
      "id": 5
    },
    {
      "title": "Tests",
      "catalog_id": 1,
      "id": 6
    }
  ],
  "articles": [
    {
      "id": 1,
      "section_id": 1,
      "title": "Начало работы Webpack",
      "text": "***Webpack***\n Webpack - программа сборщик, собирает модули в файл(ы), определённого в настройках вида.\nWebpack-у - необходимо иметь входную точку, что бы построить граф зависимостей перед тем,\nкак начать сборку. 5 версия работает в браузерах ES5+, и с Node 10+. Так же сам транспилирует,\nмодули ES2015 под браузеры в бандле.\n\nЗачем: \n1) Собирает множество файлов которые зависят друг от друга в 1 минифицированый, \nпозволяя использовать все виды импортов\n2) Позволяет работать с разными типами файлов за счёт лоадеров и плагинов\n\nГраф зависимостей - структура, которую рекурсивно строит webpack, что бы при сборке собрать \nвсе необходимые для нашего приложения зависимости, файлы и модули в бандл для браузера.\n\nУстанавливаем webpack и webpack-cli (для работы через терминал)\n```\nnpm i -D webpack webpack-cli\n```\nЗапускаем: npx webpack (с флагом --production - минифицированный, --development - нет, \n--watch следит за изменениями файлов, при изменении пересобирает, но не обновляет в браузере), все настройки при этом по-умолчанию\n\n```\nnpx webpack\n```",
      "tags": [
        4
      ]
    },
    {
      "id": 2,
      "section_id": 1,
      "title": "Конфигурация (TypeScript)",
      "text": "***Конфигурация***\n Вообще webpack может работать и без конфига (исп дефолтные настройки), \nно рекомендуется настраивать самому, для более гибкой и полной сборки.\n\nКонфиг может быть объектом или функцией, которая принимает объект env переменных\n* JS файл - module.exports = { конфиг }\n* JS функция - module.exports = () = { ...логика return { конфиг } }\n\n[онлайн генератор конфига](https://createapp.dev/webpack)\n\n!Важно Webpack можно (нужно) использовать с TypeScript,\nдля типизации необходимо установить следующие пакеты\n```\nnpm i -D node-ts typescript @types/webpack @types/node\n```\nИ настроить tsconfig, после чего мы можем деструктурировать конфиг \nи нам будут доступны следующие типы:\n* webpack.Configuration - конфиг файл\n* webpack.RuleSetRule[] - массив rules\n* webpack.WebpackPluginInstance[] - массив плагинов\n* webpack.ResolveOptions - resolve опции\n* и другие\n\nТак же отдельно типизируется\n```\nimport type {Configuration as DevServerConfiguration} from \"webpack-dev-server\";\n```\n",
      "tags": [
        4
      ]
    },
    {
      "id": 3,
      "section_id": 1,
      "title": "Работа с модулями (imports)",
      "text": "***Модули***\n Webpack поддерживает следующие виды импортов:\n\n1) ECMAScript modules - классический import/export\n! Работая с тайпскрипт, в tscongig рекомендуется указать:\n```\n\"allowSyntheticDefaultImports\": true, // если у пакета нет default импорта, создаст его вместо * as React        \n\"esModuleInterop\": true, // Позволит импортить CommonJS как ESModule\n```\n2) CommonJS modules - \"нодовский\" module.export = {} /require()\n\n3) AMD modules - асинхронные модули, где функция define (или её аналог require) принимает первым агрументом \nмассив зависимостей из модулей, и если они присутствуют в сборке, выполняет 2-ой аргумент,\ncallback. Сама функция define определена в пакете-загрузчике, таких как RequireJS, который\nвам придётся использовать, если вы хотите использовать модули типа AMD.\n! В данный момент устаревает, но были оч. популярны\n```\ndefine(['jquery', 'underscore'], function ($, _) {\n    // логика\n    return\n});\n```\n\n4) Assets - @import внутри css/sass/less файлов\n```\n@import './reset.css'\n```\n\n5) WebAssembly modules - url(...) or HTML <img src=...> file.\n```\n.windows-icon {\n  background-image: url(\"../windows.png\");\n}\n```\n\n***Абсолютные пути***\nМы можем использовать абсолютные пути, для этого необходимо:\n1) Указать предпочитать абсолютный путь\n2) Указать откуда будут импортироваться модули\n```\nresolve: {\n    preferAbsolute: true,\n    modules: [paths.src, 'node_modules'],\n}\n```\n3) Если используем TypeScript, указать в tsconfig базовый url \nи директорию откуда будет начинаться абсолютный путь \n```\n\"baseUrl\": \".\",                        \n\"paths\": {\n  \"*\": [\n    \"./src/*\"\n  ],\n}, \n```",
      "tags": [
        4
      ]
    },
    {
      "id": 4,
      "section_id": 1,
      "title": "Основные настройки",
      "text": "###Основные настройки###\n***mode***\n mode: 'production' | 'development' | 'none' - поле необходимо для настройки сборки для определённой среды,\nпри запуске скрипта можем указать webpack --mode=development, в process.env.NODE_ENV \nпоявится установленное значение. По-умолчанию production.\n***entry***\nentry: путь к входному файлу, по-умолчанию ./src/index.js, может быть массивом \n\t(несколько точек входа, для использования чанков)\n\n* вместо строки чанка, можно передать объект, в нём настроить,dependOn - чанк, \nкоторый обязательно должен быть загружен перед текущим, который в свою очаредь \nможет быть массивом из модулей ['react', 'react-dom'], filename -имя, import - модули\nкоторые обязательно должны быть загружены перед текущим, runtime  имя в рантайме,\n***output***\noutput: путь выходного файла (может быть в строку или { path, filename }), \n по-умолчанию dist/main.js В отличие от точки входа, точка выхода может быть только\n одна, В поле pathname - необходимо указать шаблон, например\n'[name][contenthash].bundle.js', для того, что бы все имена файлов были уникальными.\n\n* output.assetModuleFilename - аналог file-loader, в данном поле пишется шаблон именования файлов в лоадерах { test: /форматы файлов/, type: 'asset/resource' }\t\n\n* output.publicPath Здесь же можно указать publicPath - url на котором будет находиться данная сборка, \"/\".\nЭто необходимо для корректной работы react-router-dom v6.8 (createBrowserRouter)\nТак же можно установить publicPath, что бы собирать сразу на серв, и передать в него значение \nenv переменной __webpack_public_path__.\t\n\n* output.clear = true - очищает out директорию перед новой сборкой, замена Clean плагина\n***target***\ntarget: свойство, которое говорит где будет разворачиваться наше приложение. ('web', 'node', ...)\n***optimization***\noptimization: поле настроек для оптимизации\n\n* При подключении сторонних библиотек их код собирается в бандл, если точек входа будет 2\n(2 бандла), по умолчанию в каждом из них будет копия библиотеки. Что бы этого избежать,\nпишем здесь splitChunks: { chunks: 'all' } - вынесет общий код в файл с пометкой vendors",
      "tags": [
        4
      ]
    },
    {
      "id": 5,
      "section_id": 1,
      "title": "Loaders (module.rules)",
      "text": "***loaders***\n loaders: по-умолчанию, webpack собирает только js и json, для остальных форматов файлов\n\tнужны Loader-ы. Loaders прописываются в свойстве module -> rules, в виде массива\n\tloaders, с 2мя обязательными св-вами test - файлы, которые нужно трансформировать,\n\tuse - лоадер, который нужно использовать module: { rules: [ { test, use } ] }.\n\n- так же можно прописывать \"инлайн\", но устарело в webpack 5.\n- loaders могут выстраивать цепочку, и в каждый след лоадер, будет попадать преобразованный\nпредидущим модуль, НО ПО ИТОГУ WEBPACK ЖДЁТ JAVASCRIPT\n- если нам нужен импорт из node_module то используем след синтаксис import \"~package.css\"\n\n* на один формат фалов, может быть необходимость использовать несколько лоадеров,\nнапример .css - для этого, передаём в use массив loaders, который будет применён с конца\n[{ loader:'style-loader' }, { loader:'css-loader }, { loader:'sass-loader' }] - sass 1ый, \nв каждый из этих объектов можно передать опции\n\n* style-loader - помещает css в тэг style в head, можно заменить на MiniCssExtractPlugin.loader\nпри установленном mini-css-extract-plugin, и собирать css не в js а в отдельную папку\nв директории с билдом\n\n* css-loader - позволяет делать импорты вида import './styles.css', так же здесь можно\nнастроить css модули, для этого необходимо передать вместо строки css-loader, объект где\nmodules.auto - функция выбирающая файлы, подходящие для правила, \nmodules.localIdentName - шаблон для имени классов\n```\n{\n  loader: 'css-loader',\n  options: {\n    modules: {\n      auto: (resPath: string) => Boolean(resPath.includes('.module.')),\n      localIdentName: isDev\n        ? '[path][name]__[local]--[hash:base64:5]'\n        : '[hash:base64:8]',\n    },\n  },\n}\n```\n\n* sass-loader (less, scss, stylus) - позволяет компилировать css код препроцессоров\n! При использовании TypeScript для файлов со стилями, необходимо необходимо объявить типы в global.d.ts\n```\ndeclare module '/\\.(sc|sa|c)ss$/' {\n\tinterface IClassNames {\n\t\t[className: string]: string\n\t}\n\tconst classNames: IClassNames;\n\texport = classNames;\n}\n```\n\n* file-loader - позволяет работать с файлами (картинками png, jpeg etc, а так же url(path) в css) \nтак же file-loader позволяет работать со шрифтами\n! Устарел - замена asset/resource, можно указать output.assetModuleFilename: \n'images/[hash][ext][query]' - шаблон для имени и пути к статике\n```\n{\n  test: /\\.png/,\n  type: 'asset/resource'\n}\n```\n! При использовании TypeScript для файлов со стилями, необходимо объявить типы в global.d.ts\n```\ndeclare module '*.png';\ndeclare module '*.jpg';\ndeclare module '*.jpeg';\ndeclare module '*.svg' {\n\timport React from 'react';\n\n\tconst SVG: React.VFC<React.SVGProps<SVGSVGElement>>;\n\texport default SVG;\n}\n```\n* xml-loader - xml файлы , и т д. смотрим доку\n\n* ts-loader - позволяет компилировать JSX и TypeScript в JS\n\n* babel-loader - позволяет использовать пресеты babel, для компиляции,\nнужен для Jest, так как он не может работать с TS без него.\n! Обязательно должен быть перед ts-loader, иначе сборка упадёт\n```\n{\n  test: /\\.m?js$/,\n  exclude: /node_modules/,\n  use: {\n    loader: \"babel-loader\",\n    options: {\n      presets: ['@babel/preset-env']\n    }\n  }\n}\n```\n\n***работа с файлами***\n* svgr-loader - импортировать svg, преобразуя их в реакт компоненты.\n```\n{\n  test: /\\.svg$/,\n  use: ['@svgr/webpack'],\n}\n```\n! при работе с typescript, необходимо объявить тип в declare.d.ts\n```\ndeclare module \"*.svg\" {\n    const content: React.FunctionComponent<React.SVGAttributes<SVGElement>>;\n    export default content;\n}\n```\n* asset/resource - используется в webpack5 и выше, вместо file-loader, по сути лоадер,\nпомимо изображений, позволяет работать со шрифтами\n```\n{\n  test: /\\.(png|jpe?g|gif/woff2/woff)$/,\n  type: 'asset/resource'\n}\n```\n! при работе с typescript, необходимо объявить тип в declare.d.ts\n```\ndeclare module \"*.png\";\ndeclare module \"*.jpg\";\ndeclare module \"*.jpeg\";\n```",
      "tags": [
        4
      ]
    },
    {
      "id": 6,
      "section_id": 1,
      "title": "Plugins",
      "text": "plugins: - если loader используются для трансформации конкретных форматов, плагины имеют более \n\tширокие функции, например хот-релоад, отчистка директории перед сборкой, работа с HTML.\n\tпередается в виде массива экземпляров класса [new Plugin({ ...settings })].\n\n* Можно написать самому, по факту класс, с обязательным методом apply, \nи не обяз. свойсвом опции (взаимодействие в конструкторе)\n```\nclass MyPlugin{\n  apply(compiler) {\n   compiler.hooks.run.tap('MyPlugin', (compilation) => ...\n```\n* html-webpack-plugin - позволяет работать c HTML, в прод, можно минимизировать\nminify: { collapsWhitespace: true }, так же указать html шаблон { template: paths.html }и т п \n\n* copy-webpack-plugin  - позволяет скопировать в сборку файлы, которые не нужно будет компилировать,\nв настройки принимает массив объектов { from: 'path', to: 'path' } - для каждого файла\n\n* mini-css-extract-plugin - позволяет хранить css не в head html-я, а в отдельном файле\nНО НЕОБХОДИМО ПЕРЕДАТЬ В ЛОАДЕР экземпляр статического метода \nMiniCssExtractPlugin.loader, СЛЕВА, последним в очареди обработки, и в настройках плагина\nуказать pathname. Можно минимизировать и оптимизировать как и  html-webpack-plugin\n\n* webpack.ProgressPlugin - позволяет видеть в консоли логи с процентом сборки и текущим этапом\n\n* webpack-bundle-analyzer - позволяет вывести граф зависимостей с указанием размеров модулей\n\n* webpack.DefinePlugin - позволяет прокинуть глобальные переменны\n```\nnew webpack.DefinePlugin({\n  IS_DEV: isDev\n});\n```\n! при использовании TypeScript необходимо указать переменные в global.d.ts\n```\ndeclare const IS_DEV: boolean;\n```\n* webpack.HotModuleReplacementPlugin - позволяет подтягивать изменения кода не перезагружая страницу.\nИспользовать только в dev режиме, в webpack-dev-server необходимо передать флаг hot: true,\n! Но он плохо работает с реакт компонентами, поэтому лучше использовать @pmmmwh/react-refresh-webpack-plugin\n```\nnew webpack.HotModuleReplacementPlugin();\n```\n* @pmmmwh/react-refresh-webpack-plugin - позволяет подтягивать изменения кода не перезагружая страницу.\nХорошо работает с реакт.\n```\nnew ReactRefreshWebpackPlugin()\n```",
      "tags": [
        4
      ]
    },
    {
      "id": 7,
      "section_id": 1,
      "title": "Resolves",
      "text": "***Resolve доп настройки webpack ***\n\t\n* Абсолютный импорт\n```\npreferAbsolute: true,\nresolve.modules: [paths.src, 'node_modules'] - массив путей, где искать модули\n```\n! При использовании TypeScript, необходимо показать TS, что мы используем абсолютные импорты:\n```\n\"baseUrl\": \".\",\n\"*\": [\n  \"./src/*\"\n],\n```\n\n* mainFiles: ['index'] - имя главного файла в модуле\n\n* resolve.alias: позволяет оптимизировать пути импортов, задать шаблоны для пути\nили подменять путь\n```\n{ \n  name(пакета): path // заменить оригинальный пакет этим (лежащим в path)\n  '@name': path.resolve(...) // заменить оригинальный путь импортов этим\n  'UI': path.resolve(__dirname, 'src', 'components', 'ui') // заменить оригинальный путь импортов этим\n}\n```\n! При использовании TypeScript, необходимо показать TS, какие используются alias:\n```\n\"baseUrl\": \".\",\n\"paths\": {\n  \"UI\": [\"src/components/ui/*\"]\n}\n```\n* extensions: ['.js', '.jsx'] - указывает разрешённые к экспорту форматы (их можно будет не указывать вручную)",
      "tags": [
        4
      ]
    },
    {
      "id": 8,
      "section_id": 1,
      "title": "Dev server",
      "text": "***DevServer***\ndevServer: настройка позволяет сделать разработку удобнее, пересобирая код и обновляя приложение в браузере\nпри внесении изменений в файлы ! Необходим  webpack-dev-server\n\n* webpack-dev-server -пакет, необходимый для реализации, указываем путь к входному файлу СБОРКИ! и порт, \n{ path: 'dist/index.js', port: 8080 }\n\n* hot: bool - хот-релоад в зависимости от значения переменной NODE_ENV и пишем скрипт \n(webpack-dev-server --open(открывает прил в окне) --mode development --hot)\n\n* historyApiFallback: true - обязательный флаг в разработке, позволяет обновлять не домашнюю страницу в браузере,\n не получая 404 ошибку\n\n* devtool - позволяет управлять отображением source-map\n```\ndevtool: isDev ? 'inline-source-map' : undefined,\n```",
      "tags": [
        4
      ]
    },
    {
      "id": 9,
      "section_id": 4,
      "title": "Async reducer",
      "text": "***Async reducer***\nЧто бы уменьшить размер бандла, можно сделать некоторые редьюсеры асинхронными.\nПо примеру lazy-компонентов. И подгружать их с помощю reducerManager.\n\nreducerManager - это функция, которую, как правило распологают рядом с store.ts,\nона принимает initialReducers (редюсеры, необходимые в main бандле)\n```\nexport function createReducerManager(initialReducers: ReducersMapObject< RootState >): ReducerManager {\n  const reducers = { ...initialReducers }\n\n  let combinedReducer = combineReducers(reducers)\n\n  let keysToRemove: (keyof RootState)[] = [] // массив ключей редьюсеров, которые необходимо исключить\n\n  return {\n    getReducerMap: () => reducers, // вернуть редьюсеры\n\n    // возвращает state!, без исключённых элементов\n    reduce: (state: RootState, action: AnyAction): CombinedState< RootReducer > => {\n      if (keysToRemove.length > 0) {\n        state = { ...state }\n        keysToRemove.forEach((key) => {\n            delete state[key]\n        })\n          \n        keysToRemove = []\n      }\n      return combinedReducer(state, action)\n    },\n\n    // Добавляет реьюсер\n    add: (key: keyof RootState, reducer: Reducer) => {\n      if (!key || reducers[key]) {\n        return\n      }\n      reducers[key] = reducer\n      combinedReducer = combineReducers(reducers)\n    },\n\n    // Удаляет реьюсер\n    remove: (key: keyof RootState) => {\n      if (!key || !reducers[key]) return\n      delete reducers[key]\n      keysToRemove.push(key)\n      combinedReducer = combineReducers(reducers)\n    }\n  }\n}\n```\n\nДалее необходимо интегрировать reducerManager в store\n```\nexport function createReduxStore(initialState?: RootState) {\n    const reducerManager = createReducerManager(defaultReducers);\n\n    const store = configureStore<RootState>({\n        reducer: reducerManager.reduce,\n        devTools: IS_DEV,\n        preloadedState: initialState,\n    });\n\n    // @ts-ignore\n    store.reducerManager = reducerManager;\n\n    return store;\n}\n```\n\nПосле чего, мы сможем вызывать в lazy-компоненте useStore, и завязать добавление\nи удаление редьюсера в useEffect\n```\nconst store = useStore() as StoreWithReducerManager;\nuseEffect(() => {\n    dispatch({ type: '@INIT authReducer' });\n    store.reducerManager.add('auth', authReducer);\n\n    return () => {\n        dispatch({ type: '@Remove authReducer' });\n        store.reducerManager.remove('auth');\n    };\n}, []);\n```\n\n! Важный момент, после этого \"сломаются\" селекторы, так как они будут искать данные, которых ещё нет.\nПоэтому их необходимо будет поправить\n```\nexport const getUsername = (state: RootState) => state?.auth?.username || '';\n```\n\n! Так же сломаются декораторы сторибука, что бы это пофиксить, необходимо создать ещё один аргумент\nдля функции создающей сторе (store.ts), сделать его необязательным, так как добавлять их руками мы будем\nтолько для тестов. \n```\nasyncReducers?: DeepPartial<ReducersMapObject<RootState>>;\n```\nВ самом декораторе создаём объект со всеми необходимыми нам редьюсерами, его придётся кастить, \nдля передачи в функцию asyncReducers as ReducersMapObject<RootState> и прокидываем в св-во провайдера\nasyncReducers.",
      "tags": []
    },
    {
      "id": 10,
      "section_id": 3,
      "title": "I18n",
      "text": "*** i18next-react ***\nЭтот пакет позволяет работать с переводами в react\n```\nnpm install react-i18next i18next --save\n```\nЕсли мы хотим определять язык и иметь возможность подгружать переводы асинхронно, необходимо установить\n```\nnpm install i18next-http-backend i18next-browser-languagedetector --save\n```\nПростейший конфиг, может находиться где угодно, и импортироваться в index.ts как import './path';\nно если мы хотим хранить переводы не в папке public/localec/ru/translation.json, то это будет необходимо прописать в конфиге (см resources)\n```\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\n\nimport Backend from 'i18next-http-backend';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport ruLang from '../../path/../ru/translation.json';\n \ni18n\n  .use(Backend)\n  .use(LanguageDetector)\n  .use(initReactI18next)\n  .init({\n    resources: {\n        ru: ruLang\n        ...\n    }\n    fallbackLng: 'en',\n    debug: true,\n\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n    }\n  });\n\n\nexport default i18n;\n```\nДалее в приложении будут доступны useTranslate и импорт сущности i18n из файла конфига,\nс помощью которых можно взаимодействовать с переводами (менять язык, переводить, вытащить текущий язык и т п)\nХук так же принимает сроку с именем файла (чанка) с переводами, по умолчанию translation.json \n```\nconst { t, i18n } = useTranslation(\"chunkName?\");\n```",
      "tags": [
        5
      ]
    },
    {
      "id": 11,
      "section_id": 5,
      "title": "EsLint",
      "text": "***ES Lint***\nESLint статически анализирует ваш код, чтобы быстро найти проблемы.\nВстроен в webstorm: Настройки->CodeStyle->ESLint\nМожно включить фикс на каждое сохранение, ищет конфиг файл, который может быть js, json, yaml\nДля запуска скрипта настройки используем:\n```\nnpm init @eslint/config\n```\nСкрипт задаст вопросы, на основе которых создаст конфиг\n```\nmodule.exports = {\n    env: {\n        browser: true,\n        es2021: true,\n    },\n    extends: [\n        'plugin:react/recommended',\n        // 'plugin:@typescript-eslint/eslint-recommended',\n        // 'plugin:@typescript-eslint/recommended',\n        'eslint-config-airbnb',\n    ],\n    parser: '@typescript-eslint/parser',\n    parserOptions: {\n        ecmaFeatures: {\n            jsx: true,\n        },\n        ecmaVersion: 'latest',\n        sourceType: 'module',\n    },\n    plugins: [\n        'react',\n        '@typescript-eslint',\n    ],\n    rules: {\n        ...правила\n    },\n    globals: {\n        __IS_DEV__: true,\n    },\n};\n```\nЗдесь мы указываем среду, для которой разрабатываем (env),\nужe готовые конфиги от которых наследуем свой (extends),\nпарсер для кода, если нужен, например, typescript и его опции (parserOptions), \nплагины помогающие eslint читать и понимать наш код (plugins),\nнаши правила, в которых можно \"перезаписать\" правила из extends конфигов (rules),\nобъявления глобальных переменных (globals),\n* все правила, как правило \"гуглятся\" и настраиваются по мере роста проекта,\nно основные лучше указать сразу.\n\n! Для того, что бы иметь возможность игнорировать unused переменные, без которых\nзачастую не обойтись, учитывая что методы и св-ва типов - unused,\nможно задать следующие правила (они отслеживают unused переменные, игнорируя типы\nи переменные именованные со знака \"_\"):\n```\n'no-unused-vars': 'off',\n'@typescript-eslint/no-unused-vars': ['error', {\n    varsIgnorePattern: '^_',\n    argsIgnorePattern: '^_',\n}],\n```",
      "tags": []
    },
    {
      "id": 12,
      "section_id": 5,
      "title": "Stylelint",
      "text": "***Stylelint***\nДля начала работы устанавливаем сам пакет и конфиг.\nЕсли работаем с css -> stylelint-config-standard,\nесли с scss -> stylelint-config-standard-scss\n```\nnpm install --save-dev stylelint stylelint-config-standard-scss\n```\nдалее создаем кофиг файл в корне проекта .stylelintrc.json \n(или JS module.exports = {...), в котором можем:\n* \"отнаследоваться\" от существующего конфига с правилами (extends)\n* добавить плагины (plugins)\n* прописать правила вручную (rules)\n```\n{\n  \"extends\": [\"stylelint-config-standard\"],\n  \"plugins\": [\"stylelint-order\"],\n  \"rules\": {\n    \"order/properties-alphabetical-order\": true\n    ...\n}\n```\n* stylelint-order - плагин позволяющий настроить порядок свойств и отступы между  группами свойств, при настройке отступов, плагин конфликтует с stylelint-config-standard-scss,\nпоэтому необходимо переназначить правило declaration-empty-line-before в null и прописать\nпорядок свойств (order/order), в объекте после массива групп (order/properties-order),\nпередаются настройки для непрописанных в (order/properties-order) правил (unspecified)\n```\n{\n  \"extends\": [\n    \"stylelint-config-standard-scss\"\n  ],\n  \"plugins\": [\n    \"stylelint-order\"\n  ],\n  \"rules\": {\n    \"indentation\": [\n      4\n    ],\n    \"selector-class-pattern\": null,\n    \"declaration-empty-line-before\": null,\n    \"order/order\": [\n      \"custom-properties\",\n      \"declarations\"\n    ],\n    \"order/properties-order\": [\n      [\n        {\n          \"groupName\": \"size\",\n          \"noEmptyLineBetween\": true,\n          \"emptyLineBefore\": \"always\",\n          \"properties\": [\n            \"width\",\n            \"height\",\n            \"margin\",\n            \"padding\"\n          ]\n        },\n        {\n          \"groupName\": \"font\",\n          \"noEmptyLineBetween\": true,\n          \"emptyLineBefore\": \"always\",\n          \"properties\": [\n            \"font-family\",\n            \"font-size\",\n            \"font-weight\",\n            \"letter-spacing\",\n            \"line-height\",\n            \"color\"\n          ]\n        }\n      ],\n      {\n        \"unspecified\": \"bottom\",\n        \"emptyLineBeforeUnspecified\": \"always\"\n      }\n    ]\n  }\n}\n```",
      "tags": []
    },
    {
      "id": 13,
      "section_id": 6,
      "title": "Jest",
      "text": "***Jest (Get started, TS, React)***\nJest - это не только набор функций для тестирования JS (describe, it, expect), \nно в первую очаредь тестовая среда, платформа которая обеспечивает окружение для работы с тестами\nделает видимыми Api тестовых библиотек в окружении приложения.\n\nДля начала настройки окружения, устанавливаем Jest, отвечая на вопросы.\n```\njest --init\n```\nВажно помнить, что Jest не знает как работать с TypeScript, поэтому, для тестирования TS кода, нам\nнеобходимо преобразовать код с помощью компилятора, Jest работает с Babel. Для работы в среде React/TS,\nставим 3 пресета, для Babel.\n```\nnpm i -D @babel/preset-env @babel/preset-typescript @babel/preset-react\n```\nв webpack.rules добавлять не нужно, далее качаем типы для Jest, но для корректной работы Jest c React\nпосле установки пресетов Babel, нужно передать опцию для @babel/preset-react -> { runtime: 'automatic' },\nбез этого React не попадёт в тестовое окружение.\n\nТак же для самого Jest ставим типы\n```\nnpm install --save-dev @types/jest\n```\nПосле этого, если мы хотим тестировать React компоненты, нужно установить тестовую среду, это \nпередаётся в конфиге, в соответствующей строке, по умолчанию node.js (браузер - jsdom)\n! С 28 версии Jest - окружение jsdom ставится как отдельный пакет - jest-environment-jsdom\n\nТак же сразу необходимо указать:\n* автоматическую отчистку mock-ов после каждого теста (clearMocks)\n* путь к корневой директории (rootDir),\n* регулярку для определения файлов с тестами (testMatch),\n* директории игнорируемые тестами (testPathIgnorePatterns),\n* массив расширений файлов (moduleFileExtensions)\n```\n    clearMocks: true,\n\n    rootDir: '../../',\n\n    testMatch: [\n        '<rootDir>src/**/*@(spec|test).[tj]s?(x)'\n    ],\n\n    testPathIgnorePatterns: [\n        \"\\\\\\\\node_modules\\\\\\\\\"\n    ],\n\n    testEnvironment: 'jsdom',\n\n    moduleFileExtensions: [\n        'js',\n        'jsx',\n        'ts',\n        'tsx',\n        'json',\n        'node',\n    ],\n```\n***Расширение возможностей Jest***\nМы имеем возможность расширять функционал нашей тестовой среды, например за счёт вспомогательных\nпакетов, таких как [@testing-library/react](), который легко интегрируется с Jest (просто скачивается).\nНо мы так-же можем расширять тестовые инструменты с помощью setupTest файла, в который импортируем доп\nпакеты (например @testing-library/jest-dom), а путь к данному файлу указываем в jest.config \n```\nsetupFilesAfterEnv: [\n    path.resolve(__dirname, 'setupTests.ts'),\n],\n```\n***Отчёт о покрытии (coverage)***\nБудет полезным периодически просматривать процент покрытия тестами, для настройки данной функции \nнеобходимо, указать в конфиге:\n* куда расположить информацию о покрытии (coverageDirectory)\n* какие директории игнорировать при оценке покрытия (coveragePathIgnorePatterns)\n```\ncoverageDirectory: '<rootDir>config/jest/coverage',\n\ncoveragePathIgnorePatterns: [\n        \"\\\\\\\\node_modules\\\\\\\\\"\n\n    ],\n```\nПосле этого запустить тесты с флагом --coverage\n```\njest --config ./config/jest/jest.config.ts --coverage\n```\n***Работа с модулями и импортами Jest***\nЗачастую нам необходимо импортировать assets файлы (изображения, шрифты, mp3 и т п),\nно Jest не может работать с webpack импортами из коробки, настроить пути для импорта модулей \nнам поможет поле в конфигурации moduleNameMapper, в это поле мы можем замокать, пути для импортов\nзамокать можно:\n* для файлов пустым имортом module.exports = {} или module.exports='test-file-stub' \nСам Jest рекомендует строку test-file-stub. Так же на импорт с определённым расширением можно\nвозвращать определённый компонент (хелпер), как заглушку.\n* для модулей файлом в папке __mocks__ или файлом (может быть компонентом пример: react-markdown)\n* для стилей пустым имортом module.exports = {} или module.exports='identity-obj-proxy' \nСам Jest рекомендует identity-obj-proxy, для эфективной работы с css-modules (пакет)\n\n! Так же в этом блоке указываются алиасы, используемые в приложении, по примеру .tsconfig\n* ключ - это регулярка для определения алиаса (импорта) 'I18n/(.*)'\n* значение - это путь, которым подменяем алиас (где $1 - заменяет *, то есть все файлы директории)\n```\nmoduleNameMapper: {\n        '\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$': path.resolve(__dirname, '__mocks__', 'fileMock.ts'),\n        '\\\\.(css|scss)$': path.resolve(__dirname, '__mocks__', 'styleMock.ts'),\n        '\\\\.svg$': path.resolve(__dirname, 'testHelpers', 'MockSvgComponent.tsx'),\n        'react-markdown': path.resolve(__dirname, 'testHelpers', 'ReactMarkdown.tsx'),\n        'I18n/(.*)': '<rootDir>src/lib/i18n/config/$1',\n    }\n```",
      "tags": []
    },
    {
      "id": 14,
      "section_id": 6,
      "title": "React testing library",
      "text": "***Testing library***\n@testing-library - предоставляет инструменты для упрощения тестирования рендера компонентов\nеё пакет @testing-library/react - это специализированный инструмент для react приложений,\nон создаёт абстракцию над react-dom и react-dom/test-utils давая более простое и гибкое API.\nУстановка при работе с Jest не требует дополнительных настроек конфигурации:\n```\nnpm install --save-dev @testing-library/react\n```\nОсновные функции пакета, доступные в тестовой среде после установки:\n* render - позволяет произвести монтирование компонента с параметрами\n* waitFor - позволяет дождаться \"промис\"\n* expect - функция Jest, но мы можем расширить её возможности с помощью доп. пакетов,\nподключаемых через testSetup файл в Jest (например @testing-library/jest-dom, добавляющая\nмножество удобных способов проверки toBeInTheDocument, toHaveClass и т п)\n* fireEvent - позволяющая прокинуть изолированное конкретное событие на элемент\n* userEvent - ставится как отдельный пакет @testing-library/user-event @testing-library/dom\nи позволяет полностью воссоздать событие на элементе в среде браузера, например onClick,\nэто последовательно вызванные mousedown -> mouseup -> onclick\n* screen - даёт возможность добраться до узлов и получить из них данные\nи имеет 3 типа селекторов:\n    1) getBy... - возвращает элемент или ошибку, если элемент не найден\n    2) queryBy... - возвращает элемент или null, если элемент не найден\n    3) findBy... -  возвращает \"промис\" с результатом\nи их версии с All\n    1) getAllBy... - возвращает массив элементов или ошибку, если элементы не найдены\n    2) queryAllBy... -  возвращает массив элементов или [], если элементы не найдены\n    3) findAllBy... -  возвращает \"промис\" с результатом (массивом элементов или ошибкой)",
      "tags": []
    },
    {
      "id": 15,
      "section_id": 6,
      "title": "Storybook",
      "text": "***Storybook***\nStorybook - это витрина компонент, позволяющая изучить вынесенные компоненты,\nих параметры, увидеть как они отображаются на UI и совершать скриншотное тестирование.\n\nДля установки storybook, запускаем скрипт в корне проекта\n```\nnpx storybook init\n```\n! Есть различия при использовании разных сборщиков, если используем webpack5\n```\nnpx sb init --builder webpack5\n```\n\nДалее в корне появится директория .storybook, в которой будут содержаться 2 файла\n* main.js - основной конфиг (плагины, регулярка отбора файлов, пути к директориям)\n* preview.js - конфирурация историй (параметры отображения, декораторы)\n\nПеремещая конфиг, необходимо указать в скрипте запуска тестов новый путь с флагом -c\nбудет искать main.js, в котором тоже нужно не забыть поправить пути. \n```\n\"storybook\": \"start-storybook -p 6006 -c ./config/storybook\"\n```\n\nВажно понимать, что сама винтрина, разворачивается на localhost с помощю webpack,\nто есть под капотом зашит дефолтный конфиг, и все наши дополнения вряд ли будут работать\nпо-умолчанию, для настройки сборки сторибука ужно изменить его webpack.config, сделать это\nможно 2-я способами:\n1) Передать в main.js в свойство webpackFinal, функцию, принимающую и возвращающую кофиг\n```\n webpackFinal: async (config, { configType }) => {\n    config.resolve.alias = {\n    \t\"UI\": \"src/path/ui\"\n    }\n    return config;\n  },\n```\n\n2) Создать рядом с main.js свой файл webpack.config, функция которая так же принимает конфиг\nи возвращает конфиг.\n```\nexport default ({config}: {config: webpack.Configuration}): webpack.Configuration => {\n    return config;\n}\n```\nПо факту, сюда необходимо прописать алиасы, лоадеры и другие настроики вашей сборки необходимые\nдля корректного отображения компонент.\n\n***Decorators***\nТак же для корректного отображения компонент им требуются контексты (StoreProvider, i18n, стили)\nв этом нам могут помочь декораторы. Это функции, принимающие и возвращающие Story. Использовать\nэтот аргумент мы можем и как функцию и как компонент.\n```\nexport const StyleDecorator = (story: () => Story) => story();\nexport const ThemeDecorator = (theme: Theme) => (StoryComponent: Story) => {\n    return <div className={`app ${theme}`}><StoryComponent /></div>\n};\n```",
      "tags": []
    },
    {
      "id": 16,
      "section_id": 6,
      "title": "Loki",
      "text": "***Loki***\nЛоки позволяет снимать скриншоты со страниц Storybook, для его установки пишем\n```\nnpm i -D loki\n```\nДалее из корня запускаем init, если файл main.js с конфигурацией Storybook не в корне\nнужно указать к нему путь.\n```\nnpx loki init --config ./config/storybook/\n```\n\nВ package.json появится основная конфигурация Loki, в ней задаются типы устройств,\nразмеры экранов, для которых нужно сделать скриншоты. Так же нужно обратить внимание на \nсвойство target, это окружение в котором будут проводиться тесты (chrome.docker - докер,\nchrome.app - браузер), соответственно при запуске тестов он будет искать процесс таргетной\nпрограммы. Настраивать докер не нужно. Достаточно просто запустить.\n```\n\"loki\": {\n    \"configurations\": {\n      \"chrome.laptop\": {\n        \"target\": \"chrome.docker\",\n        \"width\": 1366,\n        \"height\": 768,\n        \"deviceScaleFactor\": 1,\n        \"mobile\": false\n      }\n    }\n  }\n```\nКоманды доступные с cli\n* loki test - сделать скриншоты, СРАВНИТЬ с эталонами\n* loki update - сделать скриншоты, ЗАМЕНИТЬ эталонамы\n* loki approve - обновить эталоны новыми файлами\n\nДля прогона в CI, в окружении должен быть докер. Сначала необходимо создать билд storybook.\nДалее запустить loki передав ему флаги --requireReference? и --reactUri - путь к билду storybook\n```\nbuild-storybook && loki --requireReference --reactUri file:./storybook-static\n```",
      "tags": []
    }
  ],
  "tags": [
    {
      "id": 1,
      "title": "build"
    },
    {
      "id": 2,
      "title": "ui"
    },
    {
      "id": 3,
      "title": "config"
    },
    {
      "id": 4,
      "title": "webpack"
    },
    {
      "id": 5,
      "title": "react env"
    }
  ]
}
